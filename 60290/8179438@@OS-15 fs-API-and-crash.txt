I V I VII / / F
IPADS
INSTITUTE OF RARALLEL
AND DISTRIBUTED SYSTEMS
文件系统API实现与崩溃一致性
上海交通大学
https://www.sjtu.edu.cn
卜版权声明
•	本内容版权归上海交通大学并行与分布式系统研究所所有
•	使用者可以将全部或部分本内容免费用于非商业用途
•	使用者在使用全部或部分本内容时请注明来源
– 内容来自：上海交通大学并行与分布式系统研究所+材料名字
•	对于不遵守此声明或者其他违法使用本内容者，将依法保留追究权
•	本内容的发布采用Creative Commons Attribution 4.0 License
– 完整文本：https://creativecommons.org/licenses/by/4.0/legalcode
2
卜文件系统API与元数据
•	应用程序通过系统调用使用这些API
– CHDIR, MKDIR, RMDIR
– CREAT, LINK, UNLINK, RENAME
– SYMLINK
– MOUNT, UNMOUNT
– OPEN, READ, WRITE, CLOSE
– SYNC
•	文件系统的两类元数据
– 磁盘上文件的元数据：静态的、在磁盘中
– 被打开文件的元数据：动态的、在内存中
3
卜文件的元数据（磁盘中）
•	拥有者/所在组ID
– 拥有该inode的用户ID 和组ID
•	权限的类型
– 拥有者、所在组、其他
– 读、写、执行
•	时间戳
– 最后一次访问 （如READ操作）
– 最后一次修改（如WRITE操作）
– 最后一次inode更新（如LINK操作）
POSIX定义的部分文件元数据（inode）
文件元数据	说 明
mode	文件模式，其中包括文件类型和文件权限
nlink	指向此文件的链接个数
uid	文件所属用户的ID
gid	文件所属用户组的ID
size	文件的大小
atime	文件数据最近访问时间
ctime	文件元数据最近修改时间
mtime	文件数据最近修改时间
4
卜被打开文件的元数据(内存中)
•	整个系统维护了一个file_table
–记录了所有打开的文件的信息
–包括：文件游标(file cursor)、引用数(ref _count)
–父子进程间可以共享文件游标
•	每个进程维护了一个fd_table
–记录了该进程每个fd所对应文件在file _table中的索引
5
卜 fd table和file table
open file table (shared by all processes) file A
file struct
6
卜文件游标Cursor
•	文件游标
–记录了一个文件中下一次操作的位置
–可以通过SEEK操作修改
Cursor
•	情况1: 共享游标
–父进程将fd传递给子进程
•	UNIX中，子进程会继承父进程所有已经打开的fd
–允许父子进程共享同一个文件
• 情况2: 非共享游标
–两个不同的进程打开同一个文件
7
卜 lseek示例
int main。
{
int fd = openC'file.txt", O.RDWR 1 O.CREAT, 0664); 9
const char* data = "hello, world、n";
writeCfd, data, strlenCdata));
12
//使用Iseek函数移动文件的读写指针
IseekCfd, 0, 5EEK_SET);
15
//使用read函数从文件中读取数据
char buffer[1024] = {0};
read(fd, buffer, sizeof(buffer));
19
printf("%s", buffer);
21
close(fd);
return 0;
}
运行结果：
-» os-fs Is a.out test.c -» os-fs ./a.out hello, world -» os-fs Is a.out	file.txt test.c
-» os-fs cat file.txt hello, world
8
卜 lseek示例
int main。
{
int fd = openC'file.txt", O.RDWR I O.CREAT, 0664);
const char* data = "hello, world、n";
write(fd, data, strlen(data));
//使用Iseek函数移动文件的读写指针
14 0/lseekCfd, 0, SEEK.SET);
//使用read函数从文件中读取数据
char buffer[1024] = {0};
read(fd, buffer, sizeof(buffer));
printfC^s", buffer);
close(fd);
return 0;
运行结果：
-	* os-fs Is
a.out aZ.out test.c test2.c
■	> os-fs /a21Pllt
-	» os-fs Is
a.out aZ.out file.txt test.c test?.c
■	> os-fs cat file.txt hello, world
9
练习：lseek
运行结果：
f os-fs ./a3.out hello, world zsxgo, world
■> os-fs cat file.txt zsxgo, world
注释28行，31行输出o, world
int mainf) {
int fd = open("file.txtn, 0_RDWR I 0_CREAT, 0664); 9
const char* data = "hello, world\nn; write(fd, data, strlen(data));
12
//使用Leek函数移动文件的读写指针
IseekCfd, 0, SEEK_SET);____
15
//使用read函数从文件中读取数据
char buffer[1024] = {0};
read(fd, buffer, sizeof(buffer));
19 ppintf(”％s", buffer);
21
//使用Iseek函数移动文件的读写指针
23 [seek(fd, 0, SEEK_SET);__ const char* datal = "zsxg"; write(fd, datal, strlen(datal));
26
//使用Iseek函数移动文件的读写指针
IseekTfd. 0・ SEEK—SET):_ read(fd, buffer, sizeof(buffer));
.„	思考：注释第28行，
pntf( %s , buffer),	会读到什么？ ，
close(fd);
return 0;
0
文件游标共享实例
注意：这个refcnt与inode的refcnt不同！
前者：fd引用数量；后者：硬链接数量
进程A
进程B
C 是B的子进程
fdtable
fd
3
^^^^^H
File Struct Pointer
P1
fd	index
3	P2
fd	index
3	P2
file_table
inode号 文件游标	refcnt
23	128	1
23	240	2
		
		
		
		
•	三个进程A、B、C 都打开了inode号为23的文件
•	进程A 和B不共享文件游标
•	进程B和C	共享文件游标
如何实现open/read接口:以访问/etc/hosts为例
Super	block	inode	inode table	data blocks
Block bitmap bitmap	A	V	A
	•0■ ooo ••o	•oo ••o •o・											root block[0]	etc block[1]	hosts block[2]	hosts block[3]	hosts block[4]
root	etc	hosts
inode	inode	inode
思考：为什么会有write？ 因为需要更新atime	12
卜 write 和close
•	write() 与read()类似
–	可能需要分配新的block
–	更新inode的size和mtime
•	close()
–	释放fd_table中的相关项
–	减小file table中相关项的refcnt
–	如果file table中相关项refcnt为0，则将其释放
13
卜删除一个打开的文件
•	进程P1打开了文件A
– 运行open，在file_table和fd_table中都增加了一项
•	进程P2将文件A删除
– 删掉了指向文件A的最后一个目录项
– 文件A的inode引用数变成了0
•	文件A的inode不会被立即释放和删除
– 直到前一个进程调用close将其关闭
– （在Windows上，则通过"禁止删除打开的文件"实现类似效果）
14
卜思考：文件访问的性能
•	一次OPEN中有多少磁盘读写?
•	一次READ中有多少磁盘读写?
以访问/etc/hosts为例
Super	block	inode	inode table
data blocks
Block bitmap bitmap (
•0■
ooo
••o
•oo
••o
•o・
root
etc
hosts
hosts
hosts
block[0] block[1] block[2] block[3] block[4]
root	etc	hosts
inode	inode	inode
read
read
open()
read
read
read
性能糟糕！
read
read()
write
read
read
read()
read
write
16
卜页缓存
性能提升！
17
卜 Vnode：缓存inode到内存中
V-node table (shared by all processes)
open file table (shared by all processes) file A
18
fsync
•	软件/硬件的数据缓存
– 缓存了最近被使用的数据块
– 缓存缺失时，从磁盘中读取
– 推迟数据向磁盘的写入
FSYNC（系统调用）
FLUSH（磁盘操作）
应用程序
文件系统
磁盘驱动
软件 缓存
磁盘缓存（硬件）
磁盘盘面
– 寻求机会批量写入，提升性能
– 问题：如果在写入前发生故障，可能会造成不一致
• fsync(fd)
– 保证对文件的所有修改被写入到存储设备
19
回
顾：mmap分配一段虚拟内存区域
通常用于把一个文件(或一部分)
– void *mmap(void *addr,
size_t length,
int prot,
int flags,
int fd, off_t offset)
•	VMA中还会包含文件映射等信息
映射到内存
//起始地址
//长度
//权限，例如PROT_READ
//映射的标志，例如MAP_PRIVATE
// -1 或者是有效fd
//偏移，例如从文件的哪里开始映射
• 也可以不映射任何文件，仅仅新建虚拟内存区域（匿名映射）
20
回
顾：VMA是如何添加的与进程创建
• 途径-1: OS在创建进程时分配
– 数据（对应ELF段）
– 代码（对应ELF段）
– 栈（初始无内容）
•	途径-2：进程运行时添加
1	.进程创建时
2	.进程运行时
	虚拟内存空间		虚拟内存空间	
从动态库的可执行一 文件中载入	1 从程序的可执行一 文件中载入一				-—栈空间增长 一通过mmap新增 一新加载代码库 ——堆空间增长
	用户栈		用户栈	
	+		1 mmap	
	代码库		代码库	
	t		代码库-2	
	用户堆		用户堆	
	数据		数据	
	代码		代码	
				
	程序刚启动完		程序运行一段时间后	
21
卜性能对比：mmap vs. read
tmac@intell2-pc:-/ieee-ai-os/fs$ time ./read total read bytes: 5242880000
real	0ml.230s
user	0m0.161s
sys	0ml,070s
tmac@intell2-pc:-/ieee-ai-os/fs$ time ./mmap
Total read 5242880000 bytes
real	0m0.002s
user	0m0.002s
sys	0m0.000s
22
卜 MMAP
addr
磁盘
L
23
卜 MMAP
2 访问触发 page fault
24
卜 MMAP
3 写内存
物理内存
磁盘
L
25
卜 MMAP
写内存
物理内存
close
或 msync
26
> 文件系统的崩溃一致性
卜 文件系统的崩溃一致性
•	文件系统中保存了多种数据结构
•	各种数据结构之间存在依赖关系与一致性要求
– inode中保存的文件大小，应该与其索引中保存的数据块个数相匹配
– inode中保存的链接数，应与指向其的目录项个数相同
– 超级块中保存的文件系统大小，应该与文件系统所管理的空间大小相同
–	所有inode分配表中标记为空闲的inode均未被使用；标记为已用的inode
均可以通过文件系统操作访问
•	突发状况(崩溃)可能会造成这些一致性被打破！
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
28
Super	block	inode	inode table	data blocks
Block bitmap bitmap	A	V	A
	••• ••• ooo	•oo ••o •o・											root block[0]	etc block[1]	hosts block[2]	hosts block[3]	hosts block[4]	hosts block[5]
root	etc	hosts
inode	inode	inode
append()	write bitmap[5] = 1	write	write inode of /etc/hosts (旧)	新的inode	block[5] = •	size : 8000	•	size : 9000	xxxxxxxxx •	pointer : block[3]	•	pointer : block[3]	xxxxxxxxx •	pointer : block[4]	•	pointer : block[4]	xxxxxxxxx
append包含三个磁盘写 •	更新block位图 •	写入新inode •	写入新数据	•	pointer : null	•	pointer : block[5] 若写入过程发生故障，有6种可能：仅1个写成功（3种），仅2个写成功（3种） 可能的错误：数据错误、空间浪费
29
卜崩溃一致性：用户期望
重启并恢复后…
1.	维护文件系统数据结构的内部的不变量 例如, 没有磁盘块既在free list中也在一个文件中
2.	仅有最近的一些操作没有被保存到磁盘中 例如：我昨天写的OS Lab的文件还存在 用户只需要关心最近的几次修改还在不在
3.	没有顺序的异常
$ echo 99 > result ; echo done > status
卜方法-1：同步元数据写+fsck
同步元数据写
•	每次元数据写入后，运行sync()保证更新后的元数据入盘
若非正常重启，则运行fsck检查磁盘，具体步骤：
•	1.检查superblock
– 例：保证文件系统大小大于已分配的磁盘块总和
– 如果出错，则尝试使用superblock的备份
•	2.检查空闲的block
– 扫描所有inode的所有包含的磁盘块
– 用扫描结果来检验磁盘块的bitmap
– 对inode bitmap也用类似方法
31
卜方法-1：同步元数据写+fsck
•	3.检查inode的状态
– 检查类型：如普通文件、目录、符号链接等
– 若类型错误，则清除掉inode以及对应的bitmap
•	4.检查inode链接
– 扫描整个文件系统树，核对文件链接的数量
– 如果某个inode存在但不在任何一个目录，则放到/lost+found
•	5.检查重复磁盘块
– 如：两个inode指向同一个磁盘块
– 如果一个inode明显有问题则删掉，否则复制磁盘块一边给一个
32
卜方法-1：同步元数据写+fsck
•	6.检查坏的磁盘块ID
– 如：指向超出磁盘空间的ID
– 问：这种情况下，fsck能做什么呢？仅仅是移除这个指针么？
•	7.检查目录
– 这是fsck对数据有更多语义的唯一的一种文件
– 保证.和..是位于头部的目录项
– 保证目录的链接数只能是1个
– 保证目录中不会有相同的文件名
33
卜方法-1的问题：太慢
•	fsck需要用多长时间？
–	对于服务器70GB磁盘（2百万个inode），需要10分钟
– 时间与磁盘的大小成比例增长
•	同步元数据写导致创建文件等操作非常慢
– 例：解压Linux内核源代码需要多久？
•	创建一个新文件需要8次磁盘写，每次10ms
•	Linux内核大概有6万个源文件
•	8x 10ms x 60000 = 1.3小时
34
卜方法-2：日志(Journaling)
•	日志：在磁盘上预留的专门空间
•	在进行修改之前，先将修改记录到日志中
–如：如何修改block-bitmap、如何修改data
•	所有要进行的修改都记录完毕后，提交日志
•	确定日志落盘后，再修改数据和元数据
•	修改完成后，删除日志
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
35
卜例: Ext4的日志
•	Data mode（即full journaling）
– 数据和元数据都写入日志区域
•	Ordered mode	默认配置
– 先写数据（原本的文件位置），再写元数据（日志）
•	Writeback mode
– 仅仅将元数据写入日志
– 数据依然写入原本的位置
– 日志和数据之间没有顺序保证
36
卜 Ordered Mode：两次Flush保证顺序
应用程序
数据
文件系统
数据
元数据
J元数据
JCmt
37
卜崩溃后，基于日志恢复
• 启动后首先检查日志区域
– 若没有任何日志记录，则无需恢复
•	扫描所有已经COMMIT的事务
– 若没有COMMIT的事务，则无需恢复
– 对已经COMMIT的事务，将元数据从日志区写到原本位置
•	完成后清空日志区域
38
»思考时间命
•	Order mode相对Data mode有什么缺点？
•	手机和笔记本电脑等设备有电池/数据中心一般会配有
UPS(不间断电源)，是否还需要保证文件系统崩 溃一致性？
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
39
卜小结
•	三个table关系
– fd table
– file struct table
– vnode table
•	mmap文件
•	文件系统日志
40