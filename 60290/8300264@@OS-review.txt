；H IPADS
» * INSTITUTE OF RARALLEL • • ■ AND DISTRIBUTED SYSTEMS
i j/文tz学
'Shanghai jiao Tong university
操作系统课程回顾
上海交通大学
https://www.sjtu.edu.cn
卜版权声明
•	本内容版权归上海交通大学并行与分布式系统研究所所有
•	使用者可以将全部或部分本内容免费用于非商业用途
•	使用者在使用全部或部分本内容时请注明来源
– 内容来自：上海交通大学并行与分布式系统研究所+材料名字
•	对于不遵守此声明或者其他违法使用本内容者，将依法保留追究权
•	本内容的发布采用Creative Commons Attribution 4.0 License
– 完整文本：https://creativecommons.org/licenses/by/4.0/legalcode
2
使用CPU资源
使用内存资源
使用设备资源
应用程序
第一部分＜
系统调用	fork() signal() waitpid()…	CPU指令	add mov bl…	系统调用	mmap() mprotect() shmat()…
					1	r	
CPU指令
进程/线程
地址映射
用户ISA
load
store
系统调用
open() write() ioctl()…
应用看到的接口
三种方式：
1.
2.
3.
直通
抽象 虚拟化
OS（抽象）
（直通）
OS（抽象）
CPU提供的接口
应用
OS
硬件
■接口
访存ISA
CPU（虚拟化）
文件
OS（抽象）
读写寄存器 特权指令
系统ISA
..Y..
第三部分
add
mov bl…
用户ISA

读写寄存器 修改页表
寄存器/页表
CPU
物理内存
..Y..
第二部分
load
store
访存ISA

读写寄存器
寄存器
中断处理
中断
设备（存储、网络、键盘、显卡…）
Y
第四部分
J
3
> 汇编与CPU指令
卜从C程序到二进制编码
//C code in mstore.c long mult2(long, long); void multstore(long x, long y, long *dest) { long t = mult2(x, y); *dest = t; }	//Assembly file in mstore.s multstore: stp	x29,	x30,	[sp,	-32]! mov	x29,	sp str	x19,	[sp,	16] mov	x19,	x2 bl	mult2 str	x0,	[x19] ldr	x19,	[sp,	16] ldp	x29,	x30,	[sp],	32 ret
//Binary code in mstore.o fd 7b be a9 fd 03 00 91 f3 0b 00 f9 f3 03 02 aa 00 00 00 94 60 02 00 f9 f3 0b 40 f9 fd 7b c2 a8 c0 03 5f d6	//Binary code in mstore fd 7b be a9 fd 03 00 91 f3 0b 00 f9 f3 03 02 aa f0 ff ff 97 60 02 00 f9 f3 0b 40 f9 fd 7b c2 a8 c0 03 5f d6
5
卜程序可见状态
内存
通用寄存器
CPU
X0	X1	X2	X3	X4	X5	X6	X7
X8	X9	X10	X11	X12	X13	X14	X15
X16	X17	X18	X19	X20	X21	X22	X23
X24	X25	X26	X27	X28	X29	X30	
0
63
31	30 29	28 27
PC
程序计数器
…NZCV
条件码	异常掩码、特权级
0	等执行状态
程序状态寄存器PSTATE
63
0 63
SPel0
SPel1
栈顶地址
地址
数据
指令
程序1栈
程序2栈
操作系统栈
程序1 代码和数据
程序2 代码和数据
操作系统 代码和数据
SP_EL0
SP_EL1
PC
6
卜寄存器间的数据搬移指令
•	指令格式：mov dst, src
–源操作数src可以是：
•	立即数
•	寄存器
–目的操作数dst必须是寄存器
7
算术指令
指令	效果	描述
add Rd,Rn,Op2	Rd ← Rn + Op2	加
sub Rd,Rn,Op2	Rd ← Rn - Op2	减
mul Rd,Rn,Op2	Rd — Rn x Op2	乘(smul/umul)
div Rd,Rn,Op2	Rd — Rn + Op2	除(sdiv/udiv)
neg Rd,Rn	Rd ← -Rn	取相反数
8
卜移位指令
lsl
lsr
9
卜移位指令
指令	效果	描述
lsl Rd,Rn,Op2	Rd ← Rn << Op2	Logical left shift
lsr Rd,Rn,Op2	Rd ← Rn >>L Op2	Logical right shift
asr Rd,Rn,Op2	Rd ← Rn >>A Op2	Arithmetic right shift
ror Rd,Rn,Op2	Rd ← Rn >>R Op2	Rotate right
最高位按照 符号扩展
63	0
asr
63	0
ror
10
卜逻辑运算指令
指令	效果	描述
eor Rd,Rn,Op2	Rd ← Rn ^ Op2	按位异或
orr Rd,Rn,Op2	Rd ← Rn | Op2	按位或
and Rd,Rn,Op2	Rd ← Rn & Op2	按位与
mvn Rd,Rn	Rd ← ~ Rn	按位取反
11
卜访存指令
指令	效果	描述
ldr R,addr	R ← mem[addr : addr+R]	从内存加载数据到寄存器
str R,addr	mem[addr : addr+Rs]	← R	把寄存器中数据写到内存
Rs指寄存器的大小（字节数）
mem[a : b] 指地址a 到地址b 的内存范围
12
寻址模式
•	寻址模式是表示内存地址的表达式
–基地址模式（索引寻址）
•	『b]
–基地址加偏移量模式（偏移量寻址）
•	[rb, offset]
–前索引寻址（寻址操作前更新基地址）
•	[rb, offset]!	rb += Offset;寻址 M[rb]
–后索引寻址（寻址操作后更新基地址）
• [rb], offset
寻址 M[rb]; rb +二 Offset
13
卜跳转指令
•	直接分支指令
–以标签对应的地址作为跳转目标
–无条件分支指令b <label>
–有条件分支指令bcond <label>，例如beq，bne，ble
•	间接分支指令
–以寄存器中的地址作为跳转目标
– br reg，例如br x0
14
函数调用与返回指令
i int square(-int n)	1	square： {卫	2	mul	w0, wO, w(	)
} i etui n n a n)	3	(ret	
5	4	cube: int	cube(int	n)	5	stp	x29,	x30, {	r	4	6	mov	x29, sp return	n	*	[square(n);]	7	str	X19,	[sp, J	8	mov	wl9,	w®	[sp, 72]! 16]
9	[bl	square	
mul	w®, wO, wj 11	tdr	xl9, [sp, tdp	x29, x30, 13	ret	L16] [sp], 32
15
函数调用指令（caller调用callee）
•	指令
-bl	label	（直接调用，调用函数）
-blr	Rn	（间接调用，调用函数指针）
•	功能
– 将返回地址存储在链接寄存器LR （x30寄存器的别名）
– 跳转到被调用者的入口地址
16
函数返回指令（callee返回caller）
• 指令
-ret	（不区分直接调用与间接调用）
• 功能
–跳转到返回地址（链接寄存器LR，Link Register）
17
卜示例：PC与LR的变化
int squareCint n) {	। return n * n;	]	i 0000000000000000 <square>： | —►©: 00 7c 60 lb	mul wO, w®, w0 i	4: c0 03 5f d6	ret
int cubeCint n) {	। return n * square(n);；	；0000000000000008 <cube>： ! —►Ig： fa ff ff 97 bl 0x0 <square> '—^lc: 00 7c 13 lb mul w% wO, wl9
调用前	调用后	返回后
18
函数调用
/调用被调用者：bl指令
/返回到调用者：ret指令
/传递数据：寄存器与栈
/寄存器使用约定：调用者保存、被调用者保存
/局部变量：存在函数栈桢中
19
卜何时发生特权级切换：发生异常
•
同步异常
问：OS处理完异常后一定返回到被打断执行的用户程序吗？
– 执行当前指令触发异常
•	第一类：用户程序主动发起：svc指令（OS利用eret指令返回）
•	第二类：非主动，例如用户程序意外访问空指针：普通ldr指令（OS“杀死”出错程序）
• 异步异常
– CPU收到中断信号
•	从外设发来的中断，例如屏幕点击、鼠标、收到网络包
•	CPU时钟中断，例如定时器超时
20
卜系统调用
•	硬件提供了一对指令svc/eret指令来在用户态、内核 态之间切换
•	系统调用
–用户与操作系统之间，类似于过程调用的接口
–通过受限的方式访问内核提供的服务
用户态	内核态
svc I	•
I next	系统调用代码
eret	21
> 虚拟内存与地址翻译
22
卜虚拟内存
应用程序-1 独立内存地址空间
应用程序-2 独立内存地址空间
虚拟内存
操作系统层：内存管理
地址翻译
硬件层：CPU将虚拟地址翻译为物理地址
23
卜虚拟地址(virtual address, va)
• Memory Management Unit（MMU）
–按照规则将虚拟地址翻译成物理地址物理内存/主存
数据
24
卜页表：分页机制的核心数据结构
• 页表包含多个页表项，存储物理页的页号（虚拟页号为索引）
物理内存 物理页0 物理页1 物理页2 物理页3 物理页4 物理页5 物理页6
其它 物理页
25
卜	AARCH64体系结构下4级页表
多级页表节省内存示例	进程1的页表
假设进程只用到0,	1,	2A36 - 1三个虚拟页
•单级页表,共需2A48/4k = 2A36个页表项，共占用2A39B
•	4级页表，仅需要一个0级页表，2个一级页表，2个二级页表，2个
1级页表页	2级页表页	3级页表页
0
2^36-1
27
卜页表项中的属性位
有效的3级页表项：第1位必须是1
63
10
7 6
54	53
1	0
页描述符：指向4K页
3级页表项
•	V(Valid)：当访问时V=0，则触发缺页异常
•	UXN(Unprivileged eXecute Never)：用户态不可执行(例如栈)
•	PXN(Privileged eXecute Never)：内核态不可执行(防止内核执行用户代码)
•	AF(Access Flag)：当访问时，MMU标记该位	Fp 用户态EL0 内核态百7
^0不可访问	可读可写
•	AP(Access Permissions)	01	可读可写	可读可写
•	DBM(Dirty Bit)：51位，ARMv8.1-TTHM特性支持
28
卜页表项中的属性位
29
卜页表项与大页
30
卜 TLB：地址翻译的加速器
31
卜如何降低TLB刷新导致的开销
•	硬件特性ASID（AARCH64）：Address Space ID
– OS为不同进程分配8位或16位ASID
•	ASID的位数由TCR _EL1的第36位（AS位）决定
•	OS负责将ASID填写在TTBR0_EL1的高8位或高16位
– TLB的每一项也会缓存ASID
•	地址翻译时，硬件会将TLB项的ASID与TTBR0_EL1的ASID对比
•	若不匹配，则TLB miss
•	使用了ASID之后
– 切换页表（即切换进程）后，不再需要刷新TLB，提高性能
– 修改页表映射后，仍需刷新TLB（为什么？）
32
卜设置页表映射是操作系统的职责
•	TTBR0_EL1和TTBR1_EL1分别指向内核和应用页表
虚拟内存	物理内存	虚拟内存
OxFFFFFFFF_FFFFFFFF
0x00000000-00000000
OxFFFFOOOO-OOOOOOOO
OxOOOOFFFF_FFFFFFFF
应用程序-1
应用程序-2
33
何时设置页表映射
• 操作系统自己使用的页表
–在启动时填写
–映射全部物理内存
•虚拟地址=物理地址+固定偏移（直接映射，Direct Mapping）
• 思考：为什么需要直接映射？
• 应用进程的页表
–立即映射
–延迟映射
34
卜合法虚拟地址信息的记录方式
• 记录进程已分配的虚拟内存区域
– 在Linux中对应vm_area_struct（VMA）结构体
– 在ChCore-Lab中对应vmregion（vmr）结构体
虚拟地址空间
操作系统中相应的数据结构
进程结构体的变化
1	struct process {~
2	//上下文
struct context *ctx;
5	〃虚拟内存
struct vmspace *vmspace;
8	• • •
9	}；
10
11	struct vmspace {
12	//页表基地址
u64 pgtbl;
14
15	//若干虚拟内存区域组成的链表
list vmregions;
17	}；
18
19	〃表示一个虚拟内存区域
20	struct vmregion {
21	//起始虚拟地址
u64 start;
23	//结束虚拟地址
24	u64 end；
25	//访问权限；
u64 perm;
27	}；
35
卜共享内存
• 基本功能
–节约内存，如共享库
–进程通信，传递数据
程序A的 虚拟内存
物理内存
程序B的 虚拟内存
程序A和B有一块共享内存
36
卜写时拷贝(copy-on-write)
•实现
-修改页表项权限
-在缺页时拷贝、恢复
•典型场景fork
-节约物理内存
-性能加速
程序A的 虚拟内存
以写时拷贝的方式共享内存
37
＞大页的利弊
• 好处
– 减少TLB缓存项的使用，提高TLB 命中率
– 减少页表的级数，提升遍历页表的效率
•	案例
– 提供API允许应用程序进行显示的大页分配
– 透明大页(Transparent Huge Pages) 机制
•	弊端
– 未使用整个大页而造成物理内存资源浪费
– 增加管理内存的复杂度
卜物理内存分配器的指标
1.资源利用率 2.分配性能 –外部碎片与内部碎片
卜伙伴系统(buddy system)
• 伙伴系统：分裂与合并(避免外部碎片)
伴块可 分裂为 下一级 的两个 伙伴块
两个连 续伙伴 块可合 并成一 个上级 伙伴块
40
卜举例：分配15K内存
当一个请求需要分配m 个物理页时，伙伴系统将寻找一个大小合适的块， 该块包含2n个物理页，且满足2n-1< m ⩽2n
链表数组	空闲链表
把空闲块按照大小放在相应的链表中
41
卜合并过程如何定位伙伴块
•	高效地找到伙伴块
– 互为伙伴的两个块的物理地址仅有一位不同
– 而且块的大小决定是哪一位
•	例如：
– 块A（0-8K）和块B（8-16K）互为伙伴块
– 块A和B的物理地址分别是0x0 和0x2000
• 仅有第13位不同，块大小是8K（213）
42
卜 SLUB分配器的思路
• 观察
–操作系统频繁分配的对象大小相对比较固定
• 基本思想
–从伙伴系统获得大块内存（名为slab）
–对每份大块内存进一步细分成固定大小的小块内存进行管理
–块的大小通常是2n个字节（一般来说，3 ⩽ n < 12）
–也可为特定数据结构增加特殊大小的块，从而减小内部碎片
43
卜 SLUB设计
• 只分配固定大小块
• 对于每个固定块大小，SLUB 分配器都会使用独立的内存
资源池进行分配
–采用best fit定位资源池
用于分配32字节
用于分配64字节
用于分配…字节
slab
slab

slab
slab

slab
slab

资源池
资源池
资源池
44
卜 SLUB小结
优势：
1.	减少内部碎片（可根据开发需求）
2.	分配效率高（常数时间）
针对每种slot大小维护两个指针：
•	current仅指向一个slab
•	分配时使用、按需更新
•	partial指向未满slab链表
•	释放时若全free，则还给伙伴系统
从伙伴系统获得的物理内存块称为slab
slab内部组织为空闲链表
1.	思考：选择哪些slot大小？
2.	思考：分配与释放的时间复杂度？
45
卜换页机制（Swapping）
• 换页的基本思想
– 用磁盘作为物理内存的补充，且对上层应用透明
– 应用对虚拟内存的使用，不受物理内存大小限制
•	如何实现
– 磁盘上划分专门的Swap分区，或专门的Swap文件
– 在处理缺页异常时，触发物理内存页的换入换出
46
卜 问题1.如何判断缺页异常是由于换页引起的
•	导致缺页异常的三种可能
–访问非法虚拟地址
–按需分配（尚未分配真正的物理页）
–内存页数据被换出到磁盘上
•	OS如何区分？
–利用VMA区分是否为合法虚拟地址（合法缺页异常）
–利用页表项内容区分是按需分配还是需要换入
47
卜	问题2：何时进行换出操作
•	策略A
– 当用完所有物理页后，再按需换出
– 回顾：alloc_page，通过伙伴系统进行内存分配
– 问题：当内存资源紧张时，大部分物理页分配操作都需要触发换 出，造成分配时延高
•	策略B
– 设立阈值，在空闲的物理页数量低于阈值时，操作系统择机（如 系统空闲时）换出部分页，直到空闲页数量超过阈值
– Linux Watermark：高水位线、低水位线、最小水位线
48
»问题3：换页机制的代价
• 优势：突破物理内存容量限制
•劣势：缺页异常+磁盘操作导致访问延迟增加
• 如何取得平衡？
– 预取机制(Prefetching)
•	预测接卸来进程要使用的页，提前换入
•	在缺页异常处理函数中，根据应用程序访存具有的空间本地性进行预取
49
卜	问题4：如何选择换出的页
•	页替换策略
–选择一些物理页换出到磁盘
–猜测哪些页面应该被换出（短期内大概率不会被访问）
–策略实现的开销
50
卜换页策略
•	FIFO
•	Second Chance
•	LRU
•	Clock
51
卜实现时钟算法
i // 在 physical-page 结构体中新增成员变量 2 struct phys4cal_page {
〃记录该物理页被映射到哪些页表项（称为反向映射） list pgtbl_entries;
•	每个物理页需要有一个“访问位”
– MMU在页表项里面为虚拟页打上“访问位”
–回顾：页表项中的Access Flag
•	如何实现
– OS在描述物理页的结构体里面记录页表项位置
•	当物理页被填写到某张页表中时，把页表项的位置记录在元数 据中（在Linux中称为“反向映射”：reverse mapping）
•	根据物理页对应的页表项中的“访问位”判断是否驱逐
•	驱逐某页时应该清空其对应的所有页表项（例如共享内存）
52
> 进程与调度
53
卜经典创建方法：fork()
•	语义：为调用进程创建一个一模一样的新进程
–调用进程为父进程，新进程为子进程
–接口简单，无需任何参数
•	fork后的两个进程均为独立进程
–拥有不同的进程id
–可以并行执行，互不干扰(除非使用特定的接口)
–父进程和子进程会共享部分数据结构(内存、文件等)
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
54
卜在程序中使用fork
•	创建一模一样的拷贝
–例子中父子进程中的x均为42
#include <stdio.h>~
#include <sys/types ・ h>
#include <unistd.h>
13
14
15
16
int main(void)
int x = 42;
int ret = fork();
if (ret == 0) {
//子进程
pri ntf("child:
} else {
〃父进程
printf("parent:
return 0;
x=96d\n", xjT
x二％d\n",
55
卜在程序中使用fork
•	使用fork的返回值来分辨父/子进程
– 0:子进程
–非0(子进程id)：父进程
1	#include <stdio.h>~
2	#include <sys/types.h>
3	ftinclude <unistd.h>
5	int main(vond)
6	{
7	~int x = 42:
8	I ]=fork。； if (ret == 0) { //.子进程.
printf(Hchild: x二％d\n", x);
} else { 〃父进程 printf ("parent: x=96d\n" , x);
return 0;
13
14
15
16
17 }
56
卜在程序中使用fork
• 独立执行
– Fork后父子进程顺序不确定，视调度策略而定
1	#1nclude <stdio.h>
2	#include <sys/types.h>
3	ftinclude <unistd.h>
5	int main(void)
6	{
int x = 42;
int ret = fork();
if (ret 二二 O) {
10	//子进程
printf ("child: x二％d\n\ x);
12	} else {
13	//父进程
printf("parent: x二％d\n", x);
15	}
16	return 0;
17	}
两种可能结果
child: x=42
parent: x=42
parent: x=42 child: x=42
57
卜线程
•	线程只包含运行时的状态
–静态部分由进程提供
–包括了执行所需的最小状态（主要是寄存器和栈）
•	一个进程可以包含多个线程
–每个线程共享同一地址空间（方便数据共享和交互）
–允许进程内并行
上海交通大学并行与分布式系统研究所（IPADS@SJTU）
58
卜在程序中如何使用线程？
•	常用库：POSIX threads（pthreads）
– 包含约60个函数的标准接口
– 实现的功能与进程相关系统调用相似
•	创建：pthread_create
•	回收：pthread_join
•	退出：pthread_exit
• 注意：一个线程执行系统调用，可能影响该进程的所有线程
– 如exit会使所有线程退出
59
卜调度指标
•	降低周转时间：任务第一次进入系统到执行结束的时间
•	降低响应时间：任务第一次进入系统到第一次给用户输出的时间
•	实时性：在任务的截止时间内完成任务
•	公平性：每个任务都应该有机会执行，不能饿死
•	开销低：调度器是为了优化系统，而非制造性能BUG
•	可扩展：随着任务数量增加，仍能正常工作
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
60
卜 First Come First Served
■■ aABC
大家排队 先来后到！
得嘞，我第一
C,先来后到！
我的问题很简单 却要等那么长时间…
问题	到达时间	解答时间 (工作量)
A	0	4
B	1	7
C	2	2
A	BC
先到先得：简单、直观
问题：平均周转、响应时间过长
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
61
Shortest Job First
简单的问题先来
ABC
我最先到， 我还是第一！
万一再来个短时间的 D，那我要等死了…
我可以先于8了。
问题	到达时间	解答时间 （工作量）
A	0	4
B	1	7
C	2	2
AC	B
短任务优先：平均周转时间短 问题：1）不公平，任务饿死 2）平均响应时间过长
上海交通大学并行与分布式系统研究所（IPADS@SJTU）
62
卜 Round Robin （时间片轮转）
®AAABC
问题	到达时间	解答时间 （工作量）
A	0	4
B	1	7
C	2	2
公平起见 每人轮流一分钟！
感觉多等了好久…
AB	AB	ABABBBB
学霸的响应时间短	C	C
了好多	I I I I I I I I I I I I I
学霸的响应得更快了	轮询：公平、平均响应时间短
问题：牺牲周转时间
上海交通大学并行与分布式系统研究所（IPADS@SJTU）
63
卜优先级调度与多级队列
Multi-Level Queue (MLQ)
1）维护多个队列，每个对应静态设置好的优先级
2）高优先级的任务优先执行
3）同优先级内使用Round Robin调度（也可使用其他调度策略）
女生队列（高优先级）Qgirl
男生队列（低优先级）Qboy
BD
上海交通大学并行与分布式系统研究所（IPADS@SJTU）
64
卜 MLFQ的主要目标与思路
•	一个无需先验知识的通用调度策略
– 周转时间低、响应时间低
– 调度开销低
•	通过动态分析任务运行历史，总结任务特征
– 类似思想的体现：页替换策略、预取
– 需要注意：如果工作场景变化频繁，效果会很差
65
卜多级反馈队列总结
•	Multi-Level Feedback Queue
–通过观察任务的历史执行，动态确定任务优先级
•	无需任务的先验知识
–同时达到了周转时间和响应时间两方面的要求
•	对于短任务，周转时间指标近似于SJF
•	对于交互式任务，响应时间指标近似于RR
–可以避免长任务的饿死
• 许多著名系统的调度器是基于MLFQ实现的
– BSD, Solaris, Windows NT 和后续Windows操作系统
66
一种公平共享的实现：彩票调度
(Lottery Scheduling)
•每次调度时，生成随机数Re OT)
• 根据R，找到对应的任务
-R=51 3 调度C
51
20	30	50
R = random(0, T) sum = 0 foreach(task in task_list) { sum += task.ticket if (R < sum) { break
schedule( )|
AB	C
67
Lottery Scheduling: Flexible Proportional-Share Resource Management. https://www.usenix.org/legacy/publications/library/proceedings/osdi/full_papers/waldspurger.pdf
步幅调度(Stride Scheduling)
•	确定性版本的Lottery Scheduling
– 可以沿用tickets的概念
•	Stride——步幅，任务一次执行增加的虚拟时间
一 stride =
MaxStride
ticket
• MaxStride是一个足够大的整数
• 本例中设为所有tickets的最小公倍数
•	Pass——累计执行的虚拟时间
	Ticket	Stride
A1	30	10
A2	50	6
B1	60	5
MaxStride = 300
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
68
步幅调度(Stride Scheduling)
A
B
/* select client with minimum pass value */ task 二 remove_queue_min(q);
/* use resource for quantum */ schedule(task);
/* compute next pass using stride */ task->pass += task->stride;
insert_queue(q, current);
挑选pass最小的任务优先执行
	Ticket	Stride
A	30	10
B	50	6
C	60	5
C
69
> 进程间通信
70
卜使用多个进程的应用
•	一些应用程序选择使用不同进程来运行不同模块
–优势-1：功能模块化，避免重复造轮子（如数据库、界面绘 制）
–优势-2：增强模块间隔离，增强安全保障（敏感数据的隔离）
–优势-3：提高应用容错能力，限制故障在模块间的传播
•	然而不同进程拥有不同的内存地址空间
–进程与进程之间无法直接进行通信和交互
–需要一种进程间通信的方式
•	IPC：Inter-Process Communication
上海交通大学并行与分布式系统研究所（IPADS@SJTU）
71
卜常见IPC的类型
IPC机制	数据抽象	参与者	方向
管道	文件接口	两个进程	单向
共享内存	内存接口	多进程	单向/双向
消息队列	消息接口	多进程	单向/双向
信号	信号接口	多进程	单向
套接字	文件接口	两个进程	单向/双向
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
72
> 同步原语
73
卜新指令-1：Test-and-Set
•	历史
– 1960年代初期，Burroughs B5000首先引入
1	int TestAndSet(int *old_ptr, int new) {
2	int old = *old_ptr; // fetch old value at old_ptr
3	*old_ptr = new; // store 'new' into old_ptr
4	return old; // return the old value
5	}
卜新指令-2：Compare-and-swap
•	另一个原子的硬件原语
– Compare-and-swap (on SPARC)
– Compare-and-exchange (on x86)
1 int CompareAndSwap(int *ptr, int expected, int new) {
2	int actual = *ptr;
3	if (actual == expected)
4	*ptr = new;
5	return actual;
6	}
卜	新指令-3：Load-linked & Store-conditional
ARM架构
1	int LoadLinked(int *ptr)	{
2	return *ptr;
3	}
4
5	int	StoreConditional(int *ptr, int value)	{
6	if (no one has updated *ptr since the	LoadLinked	to this address) {
7	*ptr =	value;
8	return	1;	//	success!
9	} else {
10	return	0;	//	failed to	update
11	}
12	}
卜新指令-4：Fetch-and-add
1	int FetchAndAdd(int *ptr) {
2	int old = *ptr;
3	*ptr = old + 1;
4	return old;
5	}
卜用Fetch-and-add 实现Ticket Lock
1	typedef	struct	__lock_t	{
2	int	ticket;
3	int	turn;
4	} lock_t;
5
6	void lock_init(lock_t *lock) {
7	lock->ticket	= 0;
8	lock->turn =	0;
9	}
10
11
12
13
14
15
16
17
18
19
void lock(lock_t	*lock) {
int myturn =	FetchAndAdd(&lock->ticket);
while (lock->turn != myturn)
;	// spin
}
void unlock(lock_t *lock) { lock->turn = lock->turn + 1;
}
和Spin Lock相比，Ticket Lock具有公平性
卜条件变量
之前互斥锁的实现中：
条件变量：利用睡眠/唤醒机制，避免无意义的等待
让操作系统的调度器调度其他进程/线程执行
while(locked)
/* busy waiting */;
条件变量：利用睡眠/唤醒机制，避免无意义的等待
线程-0
if(!somecondition)
线程-1
cond wait(condition);
调度到其他线程执行
update(some_condition);
cond_signal(condition);
Wake up and check condition again
79
卜偏向读者 的读写锁 实现示例
Reader计数器： 表示有多少读者
struct rwlock { int reader; struct lock reader_lock; struct lock writer_lock;
void lock_reader(struct rwlock *lock) {
lock (&lock->reader_lock);
lock->reader += 1;
if (lock->reader == 1) /* No reader there */ lock(&lock->writer_lock);
unlock (&lock->reader_lock);
}	第一个/最后一个reader负责获取/释放写锁
void unlock._reader (struct rwlock *lock) {
lock(&lock->reader_lock);
lock->reader -= 1;
if (lock->reader == 0) /* Is the last reader */ unlock(&lock->writer_lock);
unlock(&lock->reader_lock);
void
}
1 c c ，£. 1 c c L	t q 1 c •	只有当完全没有读者时，
°° oc wrl er~ oc '	者才能进入临界区	，
void
}
unlock_writer(struct rwlock *lock) unlock(&lock->writer_lock);
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
80
卜 同步原语对比：互斥锁vs 读写锁
•	接口不同：读写锁区分读者与写者
•	针对场景不同：获取更多程序语义，标明只读代码段，达到更好性能
•	读写锁在读多写少场景中可以显著提升读者并行度
•	即允许多个读者同时执行读临界区
•	只用写者锁，则与互斥锁的语义基本相同
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
81
卜 同步原语对比：互斥锁vs 读写锁
Reader 0	Reader 1
lock(&glock);	lock(&glock);
// Reader CS	被阻塞
unlock(&glock);
lock(&glock);
// Reader CS
unlock(&glock);
Reader 0
reader_lock(
&glock);
// Reader CS
reader_unlock( &glock);
Reader 1
reader_lock(
&glock);
// Reader CS
reader_unlock( &glock);
同时执行
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
82
卜死锁
十字路口的“困境”
void proc_A(void) { lock(A);
/* Time T1 */ lock(B);
/* Critical Section */ unlock(B);
unlock(A);
}
void proc_B(void) { lock(B);
/* Time T1 */ lock(A);
/* Critical Section */ unlock(A);
unlock(B);
}
T1时刻的死锁
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
83
卜死锁预防：方法一
避免互斥访问：通过其他手段(如代理执行)
*代理锁(Delegation Lock) 实现了该功能
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
84
卜死锁预防：方法二
不允许持有锁并等待拿其他锁：若拿不到某把锁，则把已获取的锁也放了
trylock非阻塞
while (true) {	立即返回成功或失败
if(trylock(A) == SUCC)
if(trylock(B) == SUCC) {
/* Critical Section */
unlock(B);
unlock(A);
break;
} else unlock(A);	无法获取B，那么释放A
}
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
85
死锁预防：方法三
打破循环等待：按照特定顺序获取锁
A对锁进行编号
A让所有线程递增获取
A：1号B：2号：必须先拿锁A，再拿锁B
void proc_A(void) { lock(A);
/* Time T1 */ lock(B);
/* Critical Section */ unlock(B);
unlock(A);
}
void proc_B(void) { lock(B);
/* Time T1 */ lock(A);
/* Critical Section */ unlock(A);
unlock(B);
}
任意时刻：获取最大资源号的线程可以继续执行，然后释放资源
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
86
死锁避免：银行家算法
死锁避免：运行时检查是否会出现死锁
银行家算法的核心：
•	所有线程获取资源需要通过管理者同意
•	管理者预演会不会造成死锁
■如果会造成：阻塞线程，下次再给
■如果不会造成：给线程该资源
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
87
> 文件系统与崩溃一致性
88
卜 inode：记录文件多个磁盘块的位置
• 引入inode：index node
–	记录多个磁盘块号
–	头部记录文件size信息
–	每个文件对应一个inode
–	称为文件元数据（Metadata）
•	文件读写操作
– 给定inode和文件内偏移（offset）
– 根据offset计算出对应的磁盘块号
– 若offset超出size则返回错误
inode <
最简inode，接下来进一步扩展
89
卜	inode文件系统的存储布局
•	inode表：记录所有inode
– 可以看成inode的大数组
– 每个inode使用作为索引
– 此时，inode号即为文件名
•	inode分配信息（位图）
– 记录哪些inode已分配，哪些空闲
•	超级块：Super Block
– 记录磁盘块的大小、其他信息的起始磁盘块位置，等等
– 是整个文件系统的元数据
90
卜多级inode
•	引入索引块：指向数据块；以及二级索引块：指向索引块；...
• 索引块（包括二级索引块）不在inode表的存储区域，而是在数据区域
磁盘的inode表
磁盘的数据区域
91
卜 目录文件与目录项
目录中的每条映射称为一个

录项
–	每一条目录项记录了一个inode号与文件名字符串的映射
– 一个目录可以记录很多目录项
•	目录文件的大小（占用空间）
– 与其记录的文件大小无关
• 思考：与什么因素有关？
– “目录” VS. “文件夹”
•	目录支持查找操作
– 给定一个目录文件和字符串
– 在目录文件中查找字符串，并返回对应的inode
92
卜文件的查找过程：/os-book/fs.tex
超级块 (Super Block)
1 12 13 29	••••••O・ ••o・oo・o •o・・・o・・ •••O・・・O o・ooo・o・ •••o・oo・ o・・・・oo・ o・・・・・o・		•ooo・・o・ •••••o・・ •oo・・oo・ ••oo・o・・ •o・・o・o・ •••oo・・o oo・・o・o・ o・oooo・o	43 62 38 66 33			32 12 94 76 84 30 14			36 40 29	8 57 59
14 intro.tex	54	55 80 49	23 etc	\chapter｛文件系统｝	45	*88	47	\qrcode[height=1 in]
22 ipc.tex	68	37 71 73	46 home	\label{ch:fs}	70	4		{https://ipads.se.sjtu.edu.cn/mospi/fs} \end{center}
58 fs.tex	51	52 ； 53 | 58	36 var					
56 vm.tex	92	34「 16	52 bin					\chapterend{}
34 pm.tex			63 os-book 6					
34
1	~ 11 找到文件的inode
12 ~ 17 读取文件内容
5
3
注意：inode在这里并没有size等其他信息，只记录了block number（最后一个指向索引块）；根目录是1号 inode；块分配信息是从29号块开始计算，即只考虑数据块；没有画出来的block可忽略。
93
卜创建（硬）链接：Linux中的ln命令
[usergosbook [user@osbook [usergosbook [usergosbook hello, world [usergosbook 90059313 a [usergosbook [usergosbook	~] $ touch a ~] $ In a b ~] $ echo "hello, world" > b T $ cat a ln –s a c.soft $ is -i	cat b cat c.soft ~] $ mkdi r d ~] $ In d e
In: d: Is a di rectory
94
卜创建软链接：Linux中的ln -s命令
[user@osbook	~] $ tn -s a a.link
[user@osbook	~] $ cat a.link
cat: a.link:	No such file or directory
[user@osbook	~] $ echo "hell。, world" > a
[user@osbook	~] $ cat a.link
hello, world	
[user@osbook	~] $ Is -I
-rw-t—i—	1	osbook wheel 13 6 12 19:45 a
trwxr-xr-x 1	osbook wheel 1 6 12 19:45 a.link -> a
[userQosbook	~] $ Is -5
90055602 a	90055547 a.link
[usergosbook	~] $ mkdi r d
[user@osbook	~] $ In -s d d.Unk
[user@osbook	~] $ touch d/x
[user@osbook	~] $ Is d.link
X	
[user@osbook	~] $ In -s e e
[user@osbook	~] $ cd e
cd: too many	levels of symbolic links: e
95
卜硬链接和软链接的对比
卜 文件系统的崩溃一致性
•	文件系统中保存了多种数据结构
•	各种数据结构之间存在依赖关系与一致性要求
– inode中保存的文件大小，应该与其索引中保存的数据块个数相匹配
– inode中保存的链接数，应与指向其的目录项个数相同
– 超级块中保存的文件系统大小，应该与文件系统所管理的空间大小相同
–	所有inode分配表中标记为空闲的inode均未被使用；标记为已用的inode
均可以通过文件系统操作访问
•	突发状况(崩溃)可能会造成这些一致性被打破！
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
97
卜 日志(Journaling)
•	在进行修改之前，先将修改记录到日志中
–如：如何修改block-bitmap、如何修改data
•	所有要进行的修改都记录完毕后，提交日志
•	确定日志落盘后，再修改数据和元数据
•	修改完成后，删除日志
上海交通大学并行与分布式系统研究所(IPADS@SJTU)
98
卜例: Ext4的日志
•	Data mode（即full journaling）
– 数据和元数据都写入日志区域
•	Ordered mode	默认配置
– 先写数据（原本的文件位置），再写元数据（日志）
•	Writeback mode
– 仅仅将元数据写入日志
– 数据依然写入原本的位置
– 日志和数据之间没有顺序保证
99
卜 Ordered Mode：两次Flush保证顺序
应用程序
数据
文件系统
数据
元数据
J元数据
JCmt
100
卜崩溃后，基于日志恢复
• 启动后首先检查日志区域
– 若没有任何日志记录，则无需恢复
•	扫描所有已经COMMIT的事务
– 若没有COMMIT的事务，则无需恢复
– 对已经COMMIT的事务，将元数据从日志区写到原本位置
•	完成后清空日志区域
101
使用CPU资源
使用内存资源
使用设备资源
应用程序
第一部分＜
系统调用	fork() signal() waitpid()…	CPU指令	add mov bl…	系统调用	mmap() mprotect() shmat()…
					1	r	
CPU指令
进程/线程
地址映射
用户ISA
load
store
系统调用
open() write() ioctl()…
应用看到的接口
三种方式：
1.
2.
3.
直通
抽象 虚拟化
OS（抽象）
（直通）
OS（抽象）
CPU提供的接口
应用
OS
硬件
■接口
访存ISA
CPU（虚拟化）
文件
OS（抽象）
读写寄存器 特权指令
系统ISA
..Y..
第三部分
add
mov bl…
用户ISA

读写寄存器 修改页表
寄存器/页表
CPU
物理内存
..Y..
第二部分
load
store
访存ISA

读写寄存器
寄存器
中断处理
中断
设备（存储、网络、键盘、显卡…）
Y
第四部分
____/
102