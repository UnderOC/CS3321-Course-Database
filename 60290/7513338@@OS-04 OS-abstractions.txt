I V I VII / / F
IPADS
INSTITUTE OF RARALLEL
AND DISTRIBUTED SYSTEMS
从应用视角看操作系统抽象
上海交通大学
https://www.sjtu.edu.cn
卜版权声明
•	本内容版权归上海交通大学并行与分布式系统研究所所有
•	使用者可以将全部或部分本内容免费用于非商业用途
•	使用者在使用全部或部分本内容时请注明来源
– 内容来自：上海交通大学并行与分布式系统研究所+材料名字
•	对于不遵守此声明或者其他违法使用本内容者，将依法保留追究权
•	本内容的发布采用Creative Commons Attribution 4.0 License
– 完整文本：https://creativecommons.org/licenses/by/4.0/legalcode
2
回
顾
•	特权级EL0、EL1
•	特权级切换
– 同步异常与异步异常（中断）
– 异常处理
•	异常处理函数表
•	系统寄存器：vbar_el1、esr_el1、elr_el1
•	栈切换：sp_el1和sp_el0
– 切换过程：硬件（CPU）和软件（操作系统）的分工
• 系统调用（system call）
– 一种特殊的同步异常
– svc + eret
3
回
顾
4
> 进程
5
卜分时复用有限的CPU资源
硬件概览:
•	CPU核心数量少于应用程序数量，如何运行？
型号名称：	MacBook Air	• 单个CPU核心如何运行多个应用程序？
型号标识符：	Mac14.2
芯片：	Apple M2
整昌数：	?（e产能和4能效）	.
内存:	24 GB
系统固件版本：	7459.141.1
操作系统加载程序版本：7459.141.1
序列号（系统）：	Q21545QKVG
硬件 UUID：	A50258A0-30AA-5D36-ABA9-C8200CFF60DF
预置 UDID：	00008112-001E09E83C21401E
激活锁状态：	已启用
• 类比运动场地（分时复用）
•	气膜的羽毛球场地数量有限（CPU核心数量）
•	全校的师生都想去打羽毛球（需要运行的应用程序很多）
•	由气膜管理系统安排师生在不同时间段使用场地：大家都能打上球	6
卜分时复用有限的CPU资源
•	分时复用CPU
–	让多个应用程序轮流使用处理器核心
– 何时切换：操作系统决定
•	运行时间片（例如100ms）
– 高频切换：看起来是多个应用“同时”执行
Core-0
Core-1
Core-2
Core-3
7
卜进程：操作系统对于应用程序的表示
• 通常一个应用程序对应一个进程
–在shell中输入可执行文件的名称
•	shell创建新进程，可执行文件在新进程中执行
–在图形界面双击应用图标
• 多进程程序：应用程序亦可自行创建新进程
–创建新进程，再在新进程中运行其他应用程序或 与自己一样的程序
8
卜进程在操作系统中的实现
•	操作系统提供进程的抽象用于管理应用程序
–进程标识号(Process ID，PID)
–运行状态
•	处理器上下文(CPU Context)
–地址空间
–打开的文件
9
卜程序员视角看进程
•	进程抽象为应用程序提供了“独占CPU”的假象
–程序开发不用考虑如何与其他程序共享CPU –简化编程
•	进程相关的系统调用
–创建进程
–让进程执行指定的程序
–退出进程
–进程间通信
10
> 进程切换
卜处理器上下文(CPU Context)
•	操作系统为每个进程维护处理器上下文
–包含恢复进程执行所需要的状态
–思考：进程A执行到main函数任意一条指令，切换到进 程B执行，一段时间后，再切回到进程A执行
•	为完成此过程，有哪些状态需要保存？
–具体包括：
•	PC寄存器值，栈寄存器值，通用寄存器值，状态寄存器值
12
回
顾：用户态/内核态切换时的处理器状态变化
保存上下文	保存上下文	恢复上下文	恢复上下文
（硬件）	（软件）	（软件）	（硬件）
SPSR_EL1 系统寄存器	ELR.EL1 ESR.EL1		r	一，：应用值「	（应用值	广应用值-		
			应用值"	［k用值	H应用值）-		CZZ)
			（内核值］	（内核值D	（内核值）		
		应用值」					
PSWE PC 特殊寄存器 SP_EL1			（内核值）	：内核值	内核值		*（包用值:
		应用值—	J （内核值）	：内核值	内核值		-*!.应用值
	［内核值		SP（内内值）	SP（内核值	SP：内核值	内核值	
SP_ELO	SP	〔包用值；	应用值一		jSffltt ;	-应用值		SP ：应用值
XO X1 通用寄存器 X30		应用值 应用值	:应用值，一	:内核值	f 应用值		I应用值
			〔应用值'	:内核值	f 应用值		1.应用值
		应用值）	（应用值）-		（内核值】	f（应用值）	（应用值）	
							
							
		内存					
——用户态运行f				内核态运行	►-				一用户态运行
卜进程切换的时机
•	异常导致的上下文切换
– Timer中断（如基于时间片的多任务调度）
•	用户执行系统调用并进入内核
–如：read/sleep等会导致进程阻塞的系统调用
–即使系统调用不阻塞执行，内核也可以决定执行上下
文切换，而不是将控制权返回给调用进程
14
卜进程切换示例一
进程A执行
OS执行 进程B执行
OS执行 进程A执行
时间
保存进程A的上下文
恢复进程B的上下文
保存进程B的上下文 恢复进程A的上下文
Q：Timer中断可能在任意时刻抵达，任意时刻应用进程都能切换吗？
15
卜进程切换示例二
进程A执行
OS执行 进程B执行
OS执行 进程A执行
时间
保存进程A的上下文
恢复进程B的上下文
保存进程B的上下文 恢复进程A的上下文
16
> 常见的进程相关的接口
卜获取进程ID
•	进程 ID
–每个进程都有唯一的正数PID
•	getpid()
–返回调用进程的PID
•	getppid()
–返回调用进程父进程的PID
–父进程：创建该进程的进程
18
卜获取进程ID
#include <unistd.h>
#include <sys/types.h> pid_t getpid(void);
pid_t getppid(void);
返回值：调用进程或父进程的PID
•	getpid和getppid函数返回pid_t类型的int值
•	pid_t
– Linux系统中，在types.h文件中定义为int
19
卜 Exit函数
#include <stdlib.h> void exit(int status);
这个函数没有返回值
•	exit函数终止进程并带上一个status状态
20
卜 Fork函数
• 父进程调用fork函数创建新的子进程
#include <unistd.h>
#include <sys/types.h> pid_t fork(void);
返回值：子进程为 0，父进程为子进程 PID，出错为 -1
21
卜 Fork函数
•	调用一次
–在父进程中
•	返回两次
–在父进程中，返回子进程的PID
–在子进程中，返回0
•	返回值提供了唯一明确地区分父进程和子进程执行
的方法
22
Fork函数
1.	#include "csapp.h"
2.	int main()
3.	{
4.	pid_t	pid;
5.	int x	= 1;
6.	pid =	fork();
7.	if (pid ==	0)	{	/*	child	*/
8.	printf("child :	x=%d\n",	++x);
9.	exit(0);
10.	}
11.	/* parent	*/
12.	printf("parent:	x=%d\n",	--x);
13.	exit(0);
14.	}
23
卜小思考：打印几行输出？
1.	#include "csapp.h"
2.	int main()
3.	{
4.	fork();
5.	printf("hello!\n");
6.	exit(0);
7.	}
(a) 调用一次 fork
24
卜小思考：打印几行输出？
1.	#include "csapp.h"
2.	int	main()
3.	{
4.	fork();
5.	printf("hello!\n");
6.	exit(0);
7.	}
hello
hello fork
(a)	调用一次 fork
(b)	打印两行输出
25
卜小思考：打印几行输出？
1.	#include "csapp.h"
2.	int main()
3.	{
4.	fork();
5.	fork();
6.	printf("hello!\n");
7.	exit(0);
8.	}
(a) 调用二次 fork
26
卜小思考：打印几行输出？
1.	#include "csapp.h"
2.	int	main()
3.	{
4.	fork();
5.	fork();
6.	printf("hello!\n");
7.	exit(0);
8.	}
hello>
fork hello>
fork fork
(a)	调用二次 fork
(b)	打印四行输出
27
Execve函数
#include <unistd.h> int execve(const char const char
*filename,
*argv[], const char *envp[]);
返回值：成功(不返回)，失败(-1)
• 加载和运行
– filename:可执行文件名;argv:参数列表，envp:环境变量列表
• execve
只调用一次，且永远不会返
回
– 仅仅在运行报错的时候，返回调用程序
– 例：找不到filename标识的文件
28
卜	Linux下的僵尸进程
• 进程终止后，内核不会立刻销毁该进程
– 不再运行，但仍然占用内存资源
• 进程以终止态存在，等待父进程回收
当父进程
回
收终止的子进程
–	内核把子进程的exit状态传递给父进程
– 内核移除子进程，此时子进程才被真正回收
• 终止状态下还未被
回
收的进程就是僵尸进程
1198908 pts/32	00:00:00 sample
1198909 pts/32	00:00:00 sample[~^defunct>
29
卜	Linux下的僵尸进程
•	如果父进程
–在自己终止前没有回收僵尸子进程
–内核会安排init进程回收这些子进程
•	init进程
– PID为1
–在系统初始化时由内核创建
30
卜 waitpid函数
#include <sys/types.h>
#include <sys/wait.h>
pid_t waitpid(pid_t pid, int *status, int options);
返回值：成功返回子进程 PID，出错返回 -1
31
卜 waitpid函数
pid_t waitpid(pid_t pid, int *status, int options);
•	pid>0：等待集合中只有pid子进程
•	pid=-1：等待集合包括所有子进程
• 如果没有子进程：返
回
-1，
errno
ECHILD
• 如果等待被中断：返
回
-1，
errno
EINTR
32
卜 waitpid函数
pid_t waitpid(pid_t pid, int *status, int options);
•	options=0
–挂起调用进程，等待集合中任意子进程终止
–如果等待集合中有子进程在函数调用前已经终止，
立刻返回
–返回值是导致函数返回的终止子进程pid
–该终止子进程被内核回收
33
卜 waitpid函数
pid_t waitpid(pid_t pid, int *status, int options);
•	带回被回收子线程的exit状态
– status指针不为NULL
– status包含导致子进程进入终止状态的信息
– wait.h文件包含了若干宏定义，用于解释status
35
卜 waitpid函数
1	#include "csapp.h"
2	#define N 2
3
4	int main()
5	{
6	int status, i;
7	pid_t pid;
8
9	/* Parent creates	N children */
10	for (i = 0; i < N; i++)
11	if ((pid = fork()) == 0)	/* child */
12	exit(100+i);
13
36
卜 waitpid函数
14
15
16
17
18
19
20
21
22
23
24
25
/* Parent reaps N chds. in no particular order */ while ((pid = waitpid(-1, &status, 0))	> 0)	{
if (WIFEXITED(status))
printf("child %d terminated normally with exit status=%d\n", pid, WEXITSTATUS(status));
else
printf("child %d terminated abnormally\n", pid);
}
/* The only normal term. is if there no more chds. */
if (errno != ECHILD)
unix_error("waitpid error");
exit(0);
26
}
37
卜思考：输出结果是什么？
unix>./waitpid1
child 22966 terminated normally with exit
child 22967 terminated normally with exit
unix>./waitpid1
child 22967 terminated normally with exit
child 22966 terminated normally with exit
status=100
status=101
status=101
status=100
子进程回收顺序不确定，都有可能
38
►应用程序使用CPU资源（直通+抽象）
使用CPU资源
使用内存资源
使用设备资源
应用程序
第一部分＜
应用看到的接口
系^^用
mmap() mprotect() shmat()...
地址映射
CPU?g^
load
store
系统调用
open() write() ioctlQ ...
三种方式：
1.
2.
3.
M 抽象 虚拟化
OS (抽象)
(M)
OS (抽象)
CPU提供的接口
应用 OS 硬件 ■接口
第五部分：进翰
访存ISA
MMU （虚拟化）
读写寄存器 特权指令
系统ISA
..Y. 第三部分
add mov bl...
用户ISA
读写寄存器 修改页表
寄存器/页表
CPU
物理内存
..Y
第二部分
load
store
访存ISA
7
中断
寄存器
设备（存储、网络、键盘、显卡…）

..Y
第四部分

39
> 内存
40
回
顾：内存布局
内存
通用寄存器
CPU
地址
函数A栈桢
X0	X1	X2	X3	X4	X5	X6	X7
X8	X9	X10	X11	X12	X13	X14	X15
X16	X17	X18	X19	X20	X21	X22	X23
X24	X25	X26	X27	X28	X29	X30	
0
63
31	30 29	28 27
函数B栈桢
函数C栈桢
PC
…NZCV
程序计数器
63
0
-Y
条件码
掩码、特权级、 执行状态等
SP
栈顶地址
程序状态寄存器PSTATE
数据
指令
程序数据
程序代码
程序运行 时使用的 栈
SP
PC
41
卜进程内存布局
内存
CPU
通用寄存器
地址
X0	X1	X2	X3	X4	X5	X6	X7
X8	X9	X10	X11	X12	X13	X14	X15
X16	X17	X18	X19	X20	X21	X22	X23
X24	X25	X26	X27	X28	X29	X30	
31	30 29	28 27	0
数据
栈
动态链接库
63	0
PC 程序计数器 63	0
SP 栈顶地址
NZCV
条件码	掩码、特权级、
执行状态等
程序状态寄存器PSTATE
指令
堆
数据段
代码段
42
卜思考：多个进程如何使用内存资源
Core-0 Core-1 Core-2 Core-3
内存
43
卜多个进程如何使用内存资源
内存
Core-0 Core-1 Core-2 Core-3
内存
思路1：协商划分，类比校园土地划分
•	交大5000亩土地（8G内存）
•	若干学院（若干应用进程）
•	根据学院规模占用校园土地（根据应用规模各占一部分内存）
		
	程序1栈	
	程序2栈	
	操作系统栈	
		
	程序1 代码和数据	
		
	程序2 代码和数据	
		
	操作系统 代码和数据	
协商划分方案的问题
硬件概览:
型号名称：
型号标识符：
芯片：
a^&---------
内存：
系统固件版本：
操作系统加载程序版本:
序列号（系统）：
硬件UUID：
预置UDID：
激活锁状态：
MacBook Air Mac14,2 Apple M2 8人忤能和4前触） 24 GB 7459.141.1 7459.141.1 Q21545QKVG
A50258A0-30AA-5D36-ABA9-C8200CFF60DF 00008112-001E09E83C21401E 已启用
思考：存在问题：
1.
内存大小无法满足所有应用进程的内存需求总量
2.
不同应用进程之间缺乏隔离（安全性低、容错性差）
3.
程序编写编译的难度
45
思考：程序中的地址是哪里来的？
// main.c中的C代码
void multstore(long, long, long*);
int main() {
long d;
multstore(2,	3,	&d);
printf( “2 * 3 --> %d\n”，	d);
return 0;
}


000000000	040046c <multstore>:			
40046c:	a9be7bfd	stp	x29,	x30,	[sp, #-32]!
400470:	910003fd	mov	x29, sp	
400474:	f9000bf3	str	x19, [sp,	#16]
400478:	aa0203f3	mov	x19, x2	
40047c:	94000012	bl	7ec <mult2>	
400480:	f9000260	str	x0,	[x19]	
400484:	f9400bf3	ldr	x19, [sp,	#16]
400488:	a8c27bfd	ldp	x29,	x30,	[sp],	#32
40048c:	d65f03c0	ret		
这些地址，在C代码中并没有，是从哪里来的？	编译器生成
卜再次思考：多个进程如何使用内存资源
Core-0 Core-1 Core-2 Core-3
内存
47
卜再次思考：多个进程如何使用内存资源
Core-0	Core-1	Core-2	Core-3 内存	1	^^ 思路2：分时复用，参考对于CPU资源的使用 • 每个CPU核心访问固定地址范围的内存	Core-0	Core-1	Core-2	Core-3 内存	内存	内存	内存 磁盘
•	任意时刻，一个CPU核心仅有一个应用进程执行，它能够使用该CPU核心对应的全部内存
• 进程切换时，将全部内存保存到磁盘上，并且从磁盘上恢复下一个执行进程的内存 48
卜分时复用方案的问题
问题1.磁盘写入和读取会造成严重的性能损失
应用
应用
问题2.依然存在物理内存容量限制的问题
应用
应用
应用	应用	应用	应用
Core-0 Core-1 Core-2 Core-3
内存
思路2：分时复用，参考对于CPU资源的使用
•	每个CPU核心访问固定地址范围的内存
Core-0 Core-1 Core-2 Core-3
•	任意时刻，一个CPU核心仅有一个应用进程执行，它能够使用该CPU核心对应的全部内存
•	进程切换时，将全部内存保存到磁盘上，并且从磁盘上恢复下一个执行进程的内存 49
卜对内存资源使用的目标
•	不同进程的内存地址空间具有独立性（彼此隔离）
–进程不能直接使用物理地址访问内存（缺乏管控）
•	不同进程的内存地址空间具有统一性（易于开发）
–每个进程看见的地址空间都是连续的、统一的
•	不同进程能够使用的内存总量可以超过物理内存总量
–同时要保证性能开销较小
50
卜虚拟内存
•	虚拟地址空间
–应用进程使用虚拟地址访问内存
–所有应用进程的虚拟地址空间都是统一的（方便开发）
•	地址翻译
– CPU按照OS配置的规则把虚拟地址翻译成物理地址
–翻译对于应用进程时不可见的（无需关心）
51
卜虚拟内存与物理内存
52
虚拟内存的优势：独立而统一的地址空间
tmac@intell2-pc:~/ieee-ai-os/abstractions$ cat vml.c #include <stdio.h>
int vail = 1;
int main。 {
printf("vall memory addr: %p, memory value: %d\n", &vall, vail);
while。) {}
return 0;
tmac@intell2-pc:~/ieee-ai-J
#include <stdio.h>
int
val2 = 2;
tmac@intell2-pc:~/ieee-ai-os/abstractions$ ,/vml & ,/vmZ [4] 1199812
val2 memory addr: 0x4c50f0, memory value: 2
vail memory addr: 0x4c50f0, memory value: 1
int {
main。
printf("val2 memory addr: %p, memory value: %d\n", &val2, val2); while(l) {}
return 0;
}
53
卜 虚拟内存的优势：突破物理内存容量限制
• 提高内存资源利用率
– 操作系统按需
把进程虚拟地址映射到物理地址
• 突破物理内存的容量限制
– 操作系统可以将部分虚拟内存区域 数据暂存到磁盘上
Robert.Crovella (7 Moderator	18 年 5 月
A pascal or volta GPU running in linux OS can have its memory “oversubscribed”. In that case, the GPU runtime will swap pages of memory as needed between host and device. In order to take advantage of this, the memory must be allocated with a managed allocator, such as cudaMallocManaged
[url]Programming Guide :: CUDA Toolkit Documentation 46
[url]Programming Guide :: CUDA Toolkit Documentation 7
54
卜	Linux中进程的虚拟内存布局
ffffc2122000-ffffc2143OO0 ffffae6a80O0-ffffae6ab0O0 ffffae6a7O00-ffffae6a8O00 ffffae6a6O00-ffffae6a7O00 ffffae6990OO-ffffae69bO00 ffffae67d00O-ffffae6990O0 ffffae679000-ffffae67d000 ffffae533O0O-ffffae6790O0 aaaadb9ecO00-aaaadba0dG00 aaaab26070O0^aaaab26090O0 aaaab25f7O00-aaaab25f8OO0
cat /proc/$PID/maps
[stack]
[/lib/aarch64-linux-gnu/ld-2<24.so]
[vdso]
[war]
(anonymous)
[/lib/aarch64-li nux-gnu/ld-2•24.so]
(anonymous)
[/l-ib/aarch64-l-inux-gnu/Iibc-2.24 .so] [heap]
[/home/xiaoming/hetlo] (data)
[/home/xiaoming/hello] (code)
55
卜应用程序存储格式：目标文件
•	ELF：目标文件的标准二进制格式
–可执行目标文件
–可重定位目标文件（.o）
–共享目标文件（.so）
•	支持动态链接：加载时或运行时
56
卜	ELF格式：可执行目标文件
文件的节到内 存段的映射
描述各个节
节（section）
只读内存段 （代码段）
读写内存段 （数据段）
符号表、调试信息等 （不加载到内存）
57
回
顾：常见的进程虚拟内存布局
cat /proc/$PID/maps
ffffc21220O0-ffffc2143OO0	[stack]
ffffae6a80O0-ffffae6ab0O0	[/lib/aarch64-linux-gnu/ld-2<24.so]
ffffae6a7O0O-ffffae6a8G00	[vdso]
ffffae6a6000-ffffae6a7OO0	[war]
ffffae69900O-ffffae69bO00	(anonymous)
ffffae67d000-ffffae699O00	[/lib/aarch64-li nux-gnu/ld-2•24.so]
ffffae679OO0-ffffae67d000	(anonymous)
ffffae533O00-ffffae6790O0	[/l-ib/aarch64-l-inux-gnu/Iibc-2.24 .so]
aaaadb9ec000-aaaadba0dGO0	[heap]
aaaab2607000-aaaab2609000	[/home/xiaonring/hello] (data)
aaaab25f7Q00-aaaab25f80O0	[/home/xiaoming/hello] (code)
60
卜进程使用内存资源（虚拟化+抽象）
open() write。
ioctl()...
CPU提供的接口
第五部分：进阶
应用 OS 硬件 ■接口
使用内存资源
读写寄存器 修改页表
61
> 文件
62
卜 Unix文件
•	Unix文件是一串字节序列
– B0,B1,..., Bk,...,Bm
•	所有IO设备都被抽象成文件
–如,网络设备、硬盘、终端等
– Unix提供一个基于文件的底层应用接口，即 Unix IO
•	所有输入/输出都是通过读/写文件完成
–让所有输入输出都有统一的表现方式
63
卜文件类型1
•	普通文件(regular file)：包含任意数据
–从应用程序的角度来看有两种
•	文本文件
•	二进制文件
–从内核的角度来看，没有区别
64
卜文件类型2

录(directory)也是一个文件
–由一组“文件名到文件的映射”构成
•	Linux内核使用层次化目录来组织所有文件
– /：代表根目录
bin/	dev/	home/	usr/
Is	ttyl sdal os/ include/ bin/
stdio.h stdlib.h
65
文件类型3
•	套接字(Socket)也是文件，常用于跨网络交互
•	其他文件类型包括:
–命名管道(named pipes)
–符号连接(symbolic links)
–字符/块设备(character/block devices)
66
卜打开/关闭文件
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(char *filename, int flags, mode_t mode);
返回值：成功(新文件标识符)，出错(-1)
#include <unistd.h> int close(int fd)	;
返回值：成功(0);失败(-1)
文件标识符(file descriptor, fd)
67
卜读写文件
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
返回值：成功(读到字节数)，遇到EOF(0)，失败(-1)
ssize_t write(int fd, const void *buf, size_t count);
返回值：成功(写入字节数)，失败(-1)
文件标识符(file descriptor, fd)
68
卜读写文件示例
i#include <fcntl.h>
2	#include <stdio.h>
3	#include <urristd.h>
5	int main()
6	{
7	//打开文件hello.txto O_RDONLY表示以只读方式打开
int fd 二 open("hello.txt", O_RDONLY);
io char result[14];
11	//从fd对应的文件中读取13个字节
12	read(fd, result, 13);
13	//向屏幕输出读取到的字符串
14	wr-ite(l, result, 13);
15	close(fd);
16	}
69
卜文件：对所有设备的抽象
•	存储设备
– File
•	网络设备
– Socket
• 其他设备
–同样是fd
70
卜操作设备的示例
1	// file: hello-tty.c
2	#-include <unistd.h>
3	#include <sys/fcntl.h>
4	int main()
5	{
6	//打开另一个终端的TTY设备文件，O_WRONLY表示允许写入
1 nt fd = open("/dev/pts/18", O_WRONLY);
8	//向该文件进行篇出
9	write(fd, "Hello World!\n", 13);
10	//关闭文件
11	close(fd);
12	}
Terminal 1		
[user@osbook ~] $ tty /dev/pts/18 [user@osbook ~] $ Hello World!	Terminal 2	
	[user@osbook ~] $ vim hello-tty.c [user@osbook ~] $ gcc hello-tty.c -o hello-tty [user@osbook ~] $ ./hello-tty	
71
卜 总结：OS对CPU、内存、设备的三大抽象
72