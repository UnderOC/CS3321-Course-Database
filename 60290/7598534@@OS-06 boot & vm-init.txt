I V I VII / / F
IPADS
INSTITUTE OF RARALLEL
AND DISTRIBUTED SYSTEMS
操作系统初始化
上海交通大学
https://www.sjtu.edu.cn
卜版权声明
•	本内容版权归上海交通大学并行与分布式系统研究所所有
•	使用者可以将全部或部分本内容免费用于非商业用途
•	使用者在使用全部或部分本内容时请注明来源
– 内容来自：上海交通大学并行与分布式系统研究所+材料名字
•	对于不遵守此声明或者其他违法使用本内容者，将依法保留追究权
•	本内容的发布采用Creative Commons Attribution 4.0 License
– 完整文本：https://creativecommons.org/licenses/by/4.0/legalcode
2
卜启动：一个复杂的过程
•	为什么用“boot”表示启动?
– Boot源自bootstrap –鞋带
– "pull oneself up by one's bootstraps
• 通过拽鞋带，把自己拉起来
The computer term bootstrap began as a metaphor in the 1950s. In computers, pressing a bootstrap button caused a hardwired program to read a bootstrap program from an input unit. The computer would then execute the bootstrap program, which caused it to read more program instructions. It became a self-sustaining process that proceeded without external help from manually entered instructions. As a computing term, bootstrap has been used since at least 1953.
3
卜启动流程：从上电到等待用户输入
捞 1 V A	
按下开关
•	硬件环境（除CPU）初始化 > bootloader
• 加载内核代码到内存中
内核的第一行代码 1	
•	初始化MMU、外设（如网卡、硬盘） OS kernel
•	若有多核，则初始化其他CPU核
第一个用户态应用的第一行代码	1			
•	加载shell的二进制	］用户态init进程
shell的第一行代码	•	
• 等待键盘输入
卜 shell
shell等待用户输入
4
卜从计算机上电到内核开始运行
1.	上电后，开始执行BIOS ROM中的代码
–	自检（POST: Power-On Self Test）
–	找到第一个可启动设备（如第一块磁盘）
Award Nodular BIOS V6.00PG, An Energy Star Aliy Copyright (C) 1984-99, Huard Softuare, Inc.
BIHIM/BIUZM BIOS VI.3
Hain Processor : PEHTIUH II 918HHz
Nenory Tasting : 131B7ZK QK + 1B24X Shared Henory
Ftuard Plug and Play BIOS EKtansion vl.BA
Copyright (C) 1999. Huard Sortuire, Inc.
Trend Ct>ipAu«^)irus<R) On Guard Ifer 1.64
Press DEL to enter SETUP. ALT+ra to enter flUDFLASH B9N1/2 00B-i810-H836Z7HF-6n69MrTiAC-00
–	将可启动设备的第一个块（Master Boot Record ）加载到内存固定地址中
–	跳转到bootloader的内存地址（MBR中包含bootloader）并继续执行
2.	bootloader开始执行
–	将内核的二进制文件从启动设备加载到内存中
–	若内核文件是压缩包，则对其进行解压
–	跳转到（解压后的）内核加载地址（物理地址）并继续执行
3.	内核代码开始执行
5
卜实例：树莓派bootloader
• 树莓派：上电后真正运行的第一行代码
– 板子上电后固定从0x0地址运行firmware（也称bootloader）
• firmware放在SD卡中
– 然后再由这段代码去初始化CPU、SDRAM等
– 最后再加载内核、根文件系统到内存，实现系统启动
•	不同主板厂商的实现可以不同
– 这部分代码由主板厂商提供，使用人员通常不用关心
– 树莓派的启动比较特殊：第一行代码由GPU运行
– 不同版本的树莓派也可能不一样
6
卜 内核入口函数位置
•	CPU从预定义的RAM地址读取第一行代码，由硬件厂商决定
– 树莓派：32位为0x8000，64位为0x80000
Q：这是虚拟地址还是物理地址？
kerneLaddress
kernel_address is the memory address to which the kernel image should be loaded. 32-bit kernels are loaded to address oxsooo by default, and 64-bit kernels to address 0x80000 . If kemei oid is set, kernels are loaded to the address oxo .
https://www.raspberrypi.org/documentation/configuration/config-txt/boot.md
8
卜启动流程：从上电到等待用户输入
				
	按下开关	•	硬件环境（除CPU）初始化 •	加载内核代码到内存中	A bootloader	
	内核的第一行代码 j	>	 •	初始化MMU、外设（如UART） •	若有多核，则初始化其他CPU核	A OS kernel	
第一个用户态应用的第一行代码J shell的第一行代码	J		>	 •	加载shell的二进制 1	 •	等待键盘输入	»用户态init进程 A shell	
	shell等待用户输入			
9
卜	ARMv8架构下内核启动的3个主要任务
•	设置CPU异常级别（特权级别）
– 内核通常运行在EL1，CPU上电后的异常级别不一定是EL1，如何 切换异常级别？
•	设置页表并开启虚拟内存机制
– 页表该如何配置？
– 难点：开启地址翻译的前一行指令使用物理地址，开启后立即使用虚 拟地址，前后如何衔接？
•	设置异常向量表并打开中断
– 异常向量表如何配置？
– 打开后，异常处理的指令流如何流动？
10
> 课程实验内核启动
11
ChCore启动代码
f chcore-lab $ cd kernel/arch/aarch64
f aarch64 $ Is
CMakeLists.txt boot head.S main.c plat tools.S
f kernel $ cd arch/aarch64/boot/raspi3
f raspi3 $ Is
CMakeLists.txt firmware	include	init	peripherals
两个涉及到的目录：boot/raspi3和kernel
•	boot/raspi3目录：firmware（bootloader），其余编译后放在.init段（低地址范围）
•	kernel目录：编译后放在.text段（高地址范围），kernel初始化代码入口在arch/aarch64
12
卜 ChCore内核的起始地址（编译脚本）
kernel/arch/aarch64/boot/raspi3/include/image.h
kernel/arch/aarch64/boot/linker.tpl.ld
卜 内核运行的第一行代码：准备进入EL1
9
10 BEGIN_FUNC(_start)
11	mrs	x8,	mpidr_ell /* move core ID	to x8 */
12	and	x8,	x8, #0xFF /* mask */
13	cbz	x8,	primary /* compare branch	zero */
14	/
初始时CPU运行在EL3 （由硬件厂商决定）
45	/
46 primary:
47
48	/* Turn to ell from other exception levels. */
rm64_elX_to_el
50
51	/* Prepare stack pointer and jump to C. */
52	adr	x0, boot_cpu_stack // only used for boot
53	add	x0, x0, #0x1000
54	mov	sp, x0
55
56	bl init_c
57
58	/* Should never be here */
59	b .
60 END_FUNCC_start)
设置当前EL为EL1（内核的运行级）
设置启动时用的栈（用于C的函数调用）
跳转到C代码（不再返回到_start函数）
boot/raspi3/init/start.S
14
64
65 BEGIN_FUNCC^EE3^EE)
66 mrs x9, CurrentEL // read from a reg, decided by the board
67
68	// Check the current exception level.
69	cmp x9, CURRENTEL.EL1
70 beq .Ltarget // if ELI, no need to eret, just ret
71	cmp x9, CURRENTEL_EL2
72 beq .Lin_el2 // if ELI, need to eret from EL2
73	// Otherwise, we are in EL3.
74
75 mrs x9, scr_e!3 // scr: secure configure reg
76 mov X10, SCR_EL3_NS I SCR_EL3_HCE I SCR_EL3_RW
77	orr x9, x9, xl0
78	msr scr_el3, x9
79
80	// Set the return address and exception level.
81	adr	x9, .Ltarget
82	msr	elr_el3, x9 //	elr:	exeception	link reg
83	mov	x9, SPSR_ELX_DAIF	I	SPSR_ELX_EL1H
84	msr	spsr_e!3, x9
85
1Z8
129	isb
130	eret
131
132 .Ltarget:
133 ret // retaddr in x30
134 END_FUNCCarm64_elX_to_el1)
135
树莓派启动后，CPU运行在EL3
设置scr_el3寄存器：NS、HCE、RW（后一页）
为eret做准备：
1	.设置EL3的exception link register（返回地址）
2	.设置EL3的状态寄存器SPSR
（D: debug; A: error; I: interrupt; F: fast interrupt）
isb: memory barrier，保证顺序执行
eret，跳到.Ltarget，同时进入EL1
ret:返回到start.S的50行
https://github.com/s-matyukevich/raspberry-pi-os/blob/master/docs/lesson02/rpi-os.md
15
Figure 4.38. SCR_EL3 bit assignments
https://developer.arm.com/documentation/ddi0500/j/System-Control/AArch64-register-descriptions/Secure-Configuration-Register 16
卜小知识
Bit	V	Semantic
[10] RW		Register Width control for lower exception levels. The possible values are:
	0:	Lower levels are all AArch32. This is the reset value.
	1:	The next lower level is AArch64.
[8] HCE		Hypervisor Call Enable. This bit enables the use of HVC instructions. The possible values are:
	0:	The HVC instruction is undefined at all exception levels. This is the reset value.
	1:	The HVC instruction is enabled at EL1, EL2 or EL3.
[0] NS		Non-Secure bit. The possible values are. The possible values are:
	0:	EL0 and EL1 are in Secure state, memory accesses from those exception levels can access Secure memory. This is the reset value.
	1:	EL0 and EL1 are in Non-secure state, memory accesses from those exception levels
		cannot access Secure memory.
17
boot/raspi3/init/start.S
boot/raspi3/init/init_c.c
45			
46 47	primary:		
48 49 50	/* Turn to ell from other exception levels, bl arm64_elX_to_el1		*/
51	/* Prepare stack pointer and jump to C.	*/	
52 53 54 55 56 57 58 59 60	adr	x0,	// only	used add	x0,	x0,	#0x1000 mov	sp,	x0 bl init_c -一一一一—————' /* Should never be here */ b . END_FUNCC_start)	for	boot
char
boot_cpu_stacW
#include "image.h"
typedef unsigned long u64;
2
3
4
5
6
^define INIT_STACK_SIZE 0x1000
[PLAT_CPU_NUMBER] [INIT_STACK_SIZE] ALIGNQ6);
1 ^include "boot.h"
设置栈为boot_cpu_stack，之后就可以调 用C函数了。
•	问：为什么调C函数之前要设置栈？
•	问：栈的大小是多少？为什么够？
/* Initialize UART before enabling MMU. */ early_uart_initC)； uart_send_stringCnboot: init_c\r\n");
/* Clear the bss area for the kernel image */ clear.bssO ；
65
二；,void init_c(void)
wakeup_other_coresO ； // no need for qemu
/* Initialize Boot Page Table. */
uart_send_stringCH[BOOT] Install boot page table\r\n"); init_boot_pt();
/* Call Kernel Main. */
uar七一send_stringC"[BOOT] Jump to kernel main\r\n");
(secondary_boot_flag);
/* Never reach here */
/* Enable MMU. */ ell_mmu_activate(); uart_send_stringC"[BOOT]
Enable ell MMU\r\n");
18
卜跳转到高地址运行
1
2
3
4
5
6
7
8
^pragma
^define
#define
once
SZ.16K
SZ_64K
0x4000
0x10000
#define KERNFL VADDR	0xffffff0000000000
/define ^^^^^^^^	0x80000
kernel/arch/aarch64/head.S
kernel/arch/aarch64/boot/linker.tpl.ld
12
13	#include <common/asm.h>
14	/include <common/vars.h>
15
16	BEGIN FUNCCgRBW^BHb // high memory addr
17	/*
18	*	Code	in	bootloader	specified only the primary
19	*	cpu	with	MPIDR = 0	can be boot here. So	we directly
20	*	set	the	TPIDR.EL1 to 0, which represent	the logical
21	* cpuid in the kernel
22	*/
23	mov	x3, #0
24	msr	TPIDR_EL1, x3 // set CPU ID, only the primary will run this code
25
26	Idr	x2,	=kernel_stack // high	memory	addr 换栈：高地址区域
27	add	x2,	x2, KERNEL_STACK_SIZE
28	mov	sp,	xZ // switch stack, important
29	bl	main_____
30 end FUNcdS!B・B8!Hb
31
start_kernel位于高虚拟地址：0xffffff0000000000 + init_end
问：start_kernel函数在物理内存中实际上紧邻着init（在低地址），为什么可以
跳到高地址段执行它？
19
> 页表初始化
20
	回	到init_c：页表	初始化	12 /* The number of entries in one page table page *, 13 ^define PTP_ENTRIES 512 14 /* The size of one page table page */ 15 ^define PTP.SIZE 4096 16 ^define ALIGN(n) —attribute—((—aligned__(n))〉 17 u64 boot_ttbr0_l0[PTP_ENTRIES] ALIGN(PTP_SIZE); 18 u64 boot.ttbr0_l1[PTP_ENTRIES] ALIGN(PTP_SIZE); 19 u64 boot_ttbr0_l2[PTP_ENTRIES] ALIGN(PTP_SIZE); 20 21 u64 boot_ttbrl_l0[PTP_ENTRIES] ALIGN(PTP_SIZE);	
65 66 void init_c(void) 67 { 68	/* Clear the bss area for the kernel image */ 69	clear_bss(); 70 71	/* Initialize UART before enabling MMU.	*/ 72	early_uart_initO; 73	uart_send_stringC"boot: init_c\「\n”)； 74 75	wakeup_other_coresO; // no need for qemu 76 77	/* Initialize Boot Page Table. */ 78	uart_send_stringCn[BOOT] Install boot page table\r\nn); 79	HWgBM^c： 80 81	/* Enable MMU. */ 82	ell_mmu_activateQ ； 83	uart_send_stringC"[BOOT] Enable ell MMU\r\n"); 84 85	/* Call Kernel Main.	*/ 86	uart_send_string(,'[BOOT] Jump to kernel main\r\n"); 87	start_kernel(secondary_boot_flag); 88 89	/* Never reach here */ 90 } 91			39	22 u64 boot_ttbrl_ll[PTP_ENTRIES] ALIGN(PTP_SIZE); 23 u64 boot_ttbrl_l2[PTP_ENTRIES] ALIGN(PTP_SIZE); 40 void 41 {		 42	u32	start entry idx，	6	/* Physical memory address space: 0-1G d	'	7	^define	PHYSMEM.START (0X0UL) '	ena_entry_iax,	8 define PHYSMEM_BOOT_END (0X10000000UL) 44	u32	idx;	9	#define	PERIPHERAL.BASE (0x20000000UL) 45	u64	kva；	10	^define	PHYSMEM.END (0x40000000UL) 46 47	/* TTBR0_EL1 0-1G */ 48	boot_ttbr0_l0[0] = ((u64) boot_ttbr0_ll) 1 IS_TABLE 1 IS_VALID; 49	boot_ttbr0_ll[0] = ((u64) boot_ttbr0_12) 1 IS_TABLE 1 IS_VALID; 50 51	/* Usable memory: PHYSMEM_START -P£RI£HERAL_BASE */ 52 start_entry_idx = PHYSMEM—STAR^/^^ZE—^T^^为什么旱2 M ? 为什么是2M？ 54 55	/* Map each 2M page */ 56	for (idx = start_entry_idx; idx < end_entry_idx; ++idx) { 57	boot_ttbr0_12[idx] = (PHYSMEM_START + idx * SHZE_2M) 58	1 UXN /* Unprivileged execute never */ 59	1 ACCESSED /* Set access flag */ 60	1 INNER_SHARABLE /* Sharebility */ 61	1 NORMAL_MEMORY /* Normal memory */ 62	1 IS_VALID;	设置TTBR0页表(低地址使用) 63	}		1
boot/raspi3/init/mmu.c
回
顾：2M大页与L2页表项
块描述符：指向大页
22
卜页表初始化
39
40	void flBffMWHKiCvoid)
41	{
4Z	u32	start_entry_idx;
43	u32	end_entry_idx;
44	u32	idx;
45	u64	kva;
46
47	/* TTBR0_EL1 0-1G */
48	boot_ttbr0_10[0] = ((u64) boot_ttbr0_ll) I	IS.TABLE	I	IS.VALID;
49	boot_ttbr0_ll[0] = ((u64) boot_ttbr0_12) I	IS.TABLE	I	IS.VALID;
50
51	/* Usable memory: PHYSMEM_START - PERIPHERAL_BASE */
52	start_entry_idx = PHYSMEM_START / SIZE.ZM;
53	end_entry_idx = PERIPHERAL_BASE / SIZE.2M;
54
55	/* Map each 2M page */
56 for (idx = sta「t_entry_idx; idx < end_entry_idx; ++idx) {
57	boot_ttbr0_12[idx] = (PHYSMEM_START + idx * SIZE_2M)
58	I UXN /* Unprivileged execute never */
59	I ACCESSED /* Set access flag */
60	I INNER_SHARABLE /* Sharebility */
61	I NORMAL-MEMORY /* Normal memory */
62	I IS.VALID;
63	}
17
18
19
#define INNER_SHAREABLE (0x3)
/* Please search mair_ell for these memory types. */
#define NORMAL-MEMORY	(0x4)
丑rla《； no ni=VT广匚 M^MflPV	「介丫。、
映射完内存地址（左）后，映射设备地址（右）
• 问：设备内存与物理内存有什么区别？
23
卜树莓派3b+
4G
1G
0
0x3f000000
设备地址
(type: device memory)
物理内存
(type: normal memory)
24
卜 页表设置完，开启翻译
66 void init_c(void)
67 {
68	/* Clear the bss area for the kernel image */
69	clear_bss();
70
71	/* Initialize UART before enabling MMU.	*/
72	early_uart_initC)；
73	uart_send_string("boot: init_c\r\n");
74
75	wakeup_other_cores(); // no need for qemu
76
77	/* Initialize Boot Page Table. */
78	uart_send_string(n[BOOT] Install boot page table\r\n");
79	init_boot_pt();
80
81	/* Enable MMU. */
Ho；
83	uart_send_string(n[BOOT]	Enable ell MMU\r\n“)；
84
85	/* Call Kernel Main. */
86 uart_send_string("[BOOT] Jump to kernel main\r\nn);
87	start_kernel(secondary_boot_flag);
88
89	/* Never reach here */
90 }
ell_mmu_activate
224 BEGIN_FUNC(ell_wnu_activate)		
225	stp	x29, x30, [sp, #T6]!
226	mov	x29, sp
227		
228	bl invalidate_cache_all	
229		
230	/* Invalidate TLB */	
231	tlbi	vmallelis
232	isb	
233	dsb	sy
234		
235	/* Initialize Memory Attribute Indirection Register */	
236	Idr	x8, =MMU_MAIR_ATTR1 1 MMU_MAIR_ATTR2 1 MMU_MAIR_ATTR3
237	msr	mair_ell, x8
238		
239	/* Initialize TCR.ELl */	
240	/* set <	cacheable attributes on translation walk */
241	/* CSMP	extensions) non-shareable, inner write-back write-allocate */
242	Idr	x8, =MMU_TCR_FLAGS1 1 MMU_TCR_FLAGS0 1 MMU_TCR_IPS 1 MMU_TCR_AS
243	msr	tcr_ell, x8 // translation control reg
244	isb	
245		
246	/* Write ttbr with phys addr of the translation table */	
247 248	adrp msr	x8, boot_ttbr0_10 ., 					 ttbr0_ell, x8	将页表的物理地址，
249 250	adrp msr	写入TTBR0和TTBR1
251	isb	
252		
253	mrs	x8, sctlr_ell
254	/* Enable MMU */	
255	orr	x8, x8, #SCTLR_EL1_M // set bit of MMU
256	/* Disable alignment checking */	
257	bic	x8, x8, #SCTLR_EL1_A
258	bic	x8, x8, #SCTLR_EL1_SA0 1. 将sctlr_el1寄存器写入x8
259	bic	x8, x8, #SCTLR_EL1_SA	、「… ~	,_、，、
260	orr	x8, x8, #SCTLR_ELl_nAA 2. 设置x8某些位(开关)
261 262	/* Data orr	accesses Cacheable */	3. 将x8写回sctlr_el1寄存器 Xo, Xo,	1LK_tLl_L	—
263	/* Instruction access Cacheable */	
264	orr	也 x8, #SCTLR_EL1」
265 ■	msr	sctlr_ell, x8 // commit point
266		
267	Idp	x29, x30, [sp], #16 // opposite to 226, push/pop 26
268	ret	
269 END_FUNC(ell_mmu_activate)		
卜此时的内存布局
Main peripherals
KBASE + 0x4000_0000
KBASE + 0x3F00_0000
在TTBR1中映射为物理内存
KBASE: OxFFFF_FFOO_OOOO_OOOO
0x4000.0000
0x4000.0000
0x3F00_0000
在TTBRO中映射为物理内存
0x0000.0000
DxOOOO_OOOO
Dx3F00_0000在LBR°中映射为设备内存
27
卜开启页表前后
224 BEGIN_FUNC(ell_mmu_activate)
225
226 披
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
stp	x29, x30, [sp, #-16]!
mov	xZ9, sp
mrs x8, sctlr_ell /* Enable MMU */ orr x8, x8, #SCTLR_EL1_M // set bit of MMU /* Disable alignment checking */ bic	x8,	x8,	#SCTLR_EL1_A
bic	x8,	x8,	#SCTLR_EL1_SA0
bic	x8,	x8,	#SCTLR_EL1_SA
orr	x8,	x8,	#SCTLR_ELl_nAA
/* Data accesses Cacheable */ orr	x8, x8, #SCTLR_EL1_C
/* Instruction access Cacheable */
orr	x三也，#SCTLR_EL1_I：
| msr	sctlr_ell, x8 // commit point 265时：尚未使用页表
Idp x29, x30, [sp], #16 // opposite to 226, push/pop
ret
END_FUNC(ell_mmu_activate)
267时：PC等地址已经过MMU翻译
65
66 void init_c(void)
67 {
68	/* Clear the bss area for the kernel image */
69 clear_bssO;
70
71	/* Initialize UART before enabling MMU.	*/
72	early_uart_init();
73	uart_send_stringC"boot: init_c\r\n");
74
75	wakeup_other_cores(); // no need for qemu
76
77	/* Initialize Boot Page Table. */
78	uart_send_stringC"[BOOT] Install boot page table\r\n");
79	init_boot_ptC)；
80
81	/* Enable MMU. */
82	ell_mmu_activateO 5
83	uart_send_stringC"[BOOT] Enable ell MMU\r\n")；
84
85	/* Call Kernel Main.	*/
86 uart_send_stringC"[BOOT] Jump to kernel main\r\n");
87	^^^3^^E!(secondary_boot一flag);
88
89	/* Never reach here */
90 }
执行267行，为何能顺利执行？
•	低地址范围：虚拟地址和物理地址完全相同
•	回想下页表中的映射（TTBR1）
start_kernel位于高地址段：
•	0xffffff0000000000 + init_end
•	从init_c（低地址范围）跳过去后
•	高地址范围的地址已经被映射
•	栈在start_kernel已经换成了高地址
> 异常向量表初始化
29
卜异常向量表初始化
50
51
52
53
54
55
56
57
58
59
60
61
62
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
void {
mainCpaddr_t boot-flag)
u32 ret = 0;
/* Init big kernel lock */ kernel_lock_init();
kinfo(”[ChCore] lock init finished'n”)； BUG_0N(ret != 0);
/* Init uart: no need to init the uart again uart_initC)； kinfo(”[ChCore] uart init finished\nn)；
22
23
24
25
26
27
28
29
30
31
void
}
#ifdef
#endif
#ifdef
#endif
arch_interrupt_init_per_cpu
disable_irq();
(void)
/* platform dependent init */ set_exception_vector();
plat一interrupt一init();
CHCORE_KERNEL_TEST
lab2_test_kernel_vaddrC);
/* CHCORE_KERNEL_TEST */
/* Init mm */ mm_init();
kinfoC'TChCore] mm init finished\n"};
CHCORE_KERNEL_TEST
void lab2_test_kmalloc(void);
lab2_test_kmallocC)；
void lab2_test_page_table(voia);
lab2_test_page_table();
/* CHCORE_KERNEL_TEST */ /
/* Init exception vector */
{
33
34
}
void
arch_interrupt_initCvoid)
arch_interrupt_init_per_cpuH
）；
memset(irq_handle_type, HANDLE.KERNEL, MAX_IRQ_NUM);
16
17
18
19
20
21
22
BEGIN_FUNC(set_exception_vector) adr x0, ell_vector msr vbar_ell, x0 el1_vector(异 ret
END_FUNC(set_exception_vector)
常向量表）
回顾：异常向量表基地址寄存器
30
卜异常向量表
.macro
exception_entry
label
/* Each entry should be 0x80 aligned */ .align 7
EXPORTdBeBCBB)
/* LAB 3 TODO BEGIN */
/* BLANK BEGIN */
b
.endm
Mabel
exception.entry sync.ellt exception_entry irq_ellt exception_entry fiq_ellt		// Synchronous ELlt // IRQ ELlt // FIQ ELlt // Error ELlt
exception_entry	error.ellt	
exception.entry	sync.ellh	// Synchronous ELlh
exception.entry	irq.ellh	// IRQ ELlh
exception.entry	fiq_ellh	// FIQ ELlh
exception.entry	error.ellh	// Error ELlh
exception.entry	sync_e!0_64	// Synchronous 64-bit EL0
exception_entry	irq_el0_64	// IRQ 64-bit EL0
exception.entry	fiq_el0_64	// FIQ 64-bit EL0
exception.entry	error_el0_64	// Error 64-bit EL0
exception.entry	sync_el0_32	// Synchronous 32-bit EL0
exception.entry	irq_el0_32	// IRQ 32-bit EL0
exception.entry	fiq_el0_32	// FIQ 32-bit EL0
exception.entry	error_el0_32	// Error 32-bit EL0
31
卜异常处理函数示例
sync_el0_64:
/* Since we cannot touch x0-x7, we need some extra work here */ exception_enter
mrs	xZ5,	esr_ell
Isr	x24,	x25, #ESR_EL1_EC_SHIFT
cmp	x24,	#ESR_EL1_EC_SVC_64
|el0_syscall
/* Not supported exception */ mov	x0, SYNC_EL0_64
mrs	xl, esr.ell
mrs	x2, elr_ell
bl	handle_entry_c
/* BLANK BEGIN */ bl	unlock_kernel
/* BLANK END */ exception.exit
32
卜上下文保存
39	.macro	
40	sub	sp, sp, #ARCH_EXEC_CONT_SIZE
41	stp	x0, xl, [sp, #16 * 0]
42	stp	x2, x3, [sp, #16 * 1]
43	stp	x4, x5, [sp, #16 * 2]
44	stp	x6, x7, [sp, #16 * 3]
45	stp	x8, x9, [sp, #16 * 4]
46	stp	xl0, xll, [sp, #16 * 5]
47	Stp	xl2, xl3, [sp, #16 * 6]
48	Stp	xl4, xl5, [Sp, #16 * 7]
49	Stp	xl6, xl7, [sp, #16 * 8]
50	stp	xl8, xl9, [sp, #16 * 9]
51	stp	x20, x21, [sp, #16 * 10]
52	Stp	x22, x23, [sp, #16 * 11]
53	stp	x24, x25, [sp, #16 * 12]
54	stp	x26, x27, [sp, #16 * 13]
55 56 57 58	Stp mrs mrs mrs	x28, x29, [sp, #16 * 14] xl0, sp_el0 xll, elr_ell xlZ, spsr_ell
59	stp	x30, xl0, [sp, #16 * 15]
60 61	stp .endm	xll, xl2, [sp, #16 * 16]
63 64	
	Idp xll, xl2, [sp, #16 * 16]
65 66 67 68	Idp x30, xl0, [sp, #16 * 15] msr sp_el。， xl0 msr elr_ell, xll msr spsr_ell, xlZ
69	Idp x0, xl, [sp, #16 * 0]
70	Idp x2, x3, [sp, #16 * 1]
71	Idp x4, x5, [sp, #16 * 2]
72	Idp x6, x7, [sp, #16 * 3]
73	Idp x8, x9, [sp, #16 * 4]
74	Idp xl0, xll, [sp, #16 * 5]
75	Idp xl2, xl3, [sp, #16 * 6]
76	Idp xl4, xl5, [sp, #16 * 7]
77	Idp xl6, xl7, [sp, #16 * 8]
78	Idp xl8, xl9, [sp, #16 * 9]
79	Idp x20, xZl, [sp, #16 * 10]
80	Idp x22, x23, [sp, #16 * 11]
81	Idp x24, x25, [sp, #16 * 12]
82	Idp x26, xZ7, [sp, #16 * 13]
83	Idp x28, x29, [sp, #16 * 14]
84 85 86	add sp, sp, #ARCH_EXEC_CONT_SIZE eret .endm
卜系统调用
sync_el0_64:
/* Since we cannot touch x0-x7, we need some extra work here */ exceo七ion enter1
mrs	x25, esr_ell	回顾：异常症状寄存器
Isr	x24, x25, #ESR_EL1_EC_SHIFT	ESR_EL1
cmp	x24, #ESR_EL1_EC_SVC_64	
b.eq	■el0_syscall・	
/* Not	supported exception */	
mov	x0, SYNC_EL0_64	
mrs	xl, esr.ell	
mrs	x2, elr_ell	
bl	handle_entry_c	
/* BLANK BEGIN */
bl unlock_kernel
/* BLANK END */ exception.exit
34
卜系统调用
sync_el0_64:
/* Since we cannot touch x0-x7, we need exception_enter
mrs	x25,	esr_ell
Isr	x24,	x25, #ESR_EL1_EC_SHIFT
cmp	x24,	#ESR_EL1_EC_SVC_64
|el0_syscall|
/* Not supported exception */ mov	x0, SYNC_EL0_64
mrs	xl, esr.ell
mrs	x2, elr_ell
bl	handle_entry_c
/* BLANK BEGIN */ bl	unlock_kernel
/* BLANK END */ exception.exit
some extra work here */
el0_syscall:
					
adr	x27,	lsyscall_tc	Me.	// syscall table in	x27
uxtw	xl6,	w8		// syscall number ir	i xl6
ld「	X16,	[x27, xl6,	Isl #3]	// find the syscall	entry
bin	xl6				
/* Ret from syscall */ str	x0, [sp]
/* BLANK BEGIN */ bl	unlock_kernel
/* BLANK END */
55 const void *kW=»・H・WSE「NR SYSCALL] = {
56	[0 ・*• NR—SYSCALL - 1] = sys_debug,
57	/* lab3 syscalls finished */
58
59	[SYS_getc] = sys_getc,
60	[SYS_yield] = sys_yield,
61	[SYS_create_device_pmo] = sys_create_device_pmo,
62	[SYS_unmap_pmo] = sys_unmap_pmo,
63	[SYS_create_thread] = sys_create_thread,
64	[SYS_create_process] = sys_create_process,
65	[SYS_register_server] = sys_register_server,
66	[SYS_register_client] = sys_register_client,
67	[SYS_ipc_call] = sys_ipc_call,
68	[SYS_ipc_return] = sys_ipc_return,
69	ESYS_cap_copy_to] = sys_cap_copy_to,
70	[SYS_cap_copy_from] = sys_cap_copy_from,
71	[SYS_set_affi ni ty] = sys_set_affi ni ty,
72	[SYS_get_affinity] = sys_get_affi ni ty,
73	/*・・•*/
74	[SYS_get_cpu_id] = sys_get_cpu_id,
75
76	[SYS_create_pmos] = sys_create_pmos,
77	[SYS_map_pmos]	=	sys_map_pmos,
78	[SYS_write_pmo] = sys_write_pmo,
79	[SYS_read_pmo]	=	sys_read_pmo,
80	[SYS_transfer_caps] = sys_transfer_caps,
81
82	/* TMP FS */
83	[SYS_fs_load_cpio] = sys_fs_load_cpio,
84
85	[SYS_top] = sys.top,
86	[SYS_debug] = sys_debug
87 };
267 /* syscalls */
268 int sys_create_process(void)
269 {
270	struct	process	*new_process;
271	struct	vmspace	*vmspace;
272	int cap, r;
273
274	/* cap	current	process */
275 new_process = obj_alloc(TYPE_PROCESS, sizeofC*new_process));
276	if C!new_process) {
277	r = -ENOMEM;
278	goto out_fail;
279	}
36
卜小结：从实验内核看系统初始化
•	设置CPU异常级别为EL1
•	设置页表并开启虚拟内存机制
– TTBR0_EL1:虚拟地址=物理地址
– TTBR1_EL1:虚拟地址=物理地址+ OFFSET
•	设置异常向量表
– 每个异常向量表项跳转到对应的异常处理函数
– 处理异常前保存进程上下文、返回进程前恢复其上下文
37